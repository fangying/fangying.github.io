<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://kernelgo.org/theme/css/style.min.css?fc5adb95">

        <link rel="dns-prefetch" href="//fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>

        <meta name="author" content="Yori Fang" />

        <meta name="description" content="virtio overview
" />
        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="virtualization, virtio, virtio-net, virtio-scsi, virtio-blk, virtqueue, virtualization, " />

<meta property="og:title" content="Virtio Spec Overview "/>
<meta property="og:url" content="https://kernelgo.org/virtio-overview.html" />
<meta property="og:description" content="virtio overview" />
<meta property="og:site_name" content="kernelgo" />
<meta property="og:article:author" content="Yori Fang" />
<meta property="og:article:published_time" content="2019-09-13T23:00:00+08:00" />
<meta property="og:article:modified_time" content="2019-09-13T23:00:00+08:00" />
<meta name="twitter:title" content="Virtio Spec Overview ">
<meta name="twitter:description" content="virtio overview">

        <title>Virtio Spec Overview  · kernelgo
</title>
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-107392039-1', 'auto');
    ga('send', 'pageview');
</script>


    </head>
    <body>
        <div id="content">
            <div class="navbar navbar-static-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="https://kernelgo.org/"><span class=site-name>kernelgo</span></a>
                        <div class="nav-collapse collapse">
                            <ul class="nav pull-right top-menu">
                                <li >
                                    <a href=
                                       https://kernelgo.org
                                    >Home</a>
                                </li>
                                <li ><a href="https://kernelgo.org/pages/about.html">About</a></li>
                                <li ><a href="https://kernelgo.org/categories.html">Categories</a></li>
                                <li ><a href="https://kernelgo.org/tags.html">Tags</a></li>
                                <li ><a href="https://kernelgo.org/archives.html">Archives</a></li>
                                <li><form class="navbar-search" action="https://kernelgo.org/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container-fluid">
                <div class="row-fluid">
                    <div class="span1"></div>
                    <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
        <h1>
            <a href="https://kernelgo.org/virtio-overview.html">
                Virtio Spec Overview
            </a>
        </h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">
            
            <h2>摘要</h2>
<p>半虚拟化设备(Virtio Device)在当前云计算虚拟化场景下已经得到了非常广泛的应用，
并且现在也有越来越多的物理设备也开始支持Virtio协议，即所谓的<code>Virtio Offload</code>，
通过将virtio协议卸载到硬件上（例如virtio-net网卡卸载，virtio-scsi卸载）让物理机和虚拟机都能够获得加速体验。
本文中我们来重点了解一下virtio技术中的一些关键点，方便我们加深对半虚拟化的理解。
本文适合对IO虚拟化有一定了解的人群阅读，本文的目的是对想要了解virtio内部机制的读者提供帮助。</p>
<p>在开始了解virtio之前，我们先思考一下几个相关问题：</p>
<ul>
<li>virtio设备有哪几种呈现方式?</li>
<li>virtio-pci设备的配置空间都有哪些内容？</li>
<li>virtio前端和后端基于共享内存机制进行通信，它是凭什么可以做到无锁的？</li>
<li>virtio机制中有那几个关键的数据结构？virtio配置接口存放在哪里？virtio是如何工作的？</li>
<li>virtio前后端是如何进行通信的？irqfd和ioeventfd是什么回事儿？在virtio前后端通信中是怎么用到的？</li>
<li>virtio设备支持MSIx，在qemu/kvm中具体是怎么实现对MSIx的模拟呢？</li>
<li>virtio modern相对于virtio legay多了哪些新特性？</li>
</ul>
<h2>0. 简单了解一下Virtio Spec协议</h2>
<p>virtio协议标准最早由IBM提出，virtio作为一套标准协议现在有专门的技术委员会进行管理，
具体的标准可以访问<a href="http://docs.oasis-open.org/virtio/virtio/v1.0/virtio-v1.0.html"><code>virtio</code>官网</a>，
开发者可以向技术委员会提供新的virtio设备提案（<code>RFC</code>），经过委员会通过后可以增加新的virtio设备类型。</p>
<p>组成一个virtio设备的四要素包括：
<strong>设备状态域，<code>feature bits</code>，设备配置空间，一个或者多个<code>virtqueue</code></strong>。
其中设备状态域包含6种状态：</p>
<ul>
<li>ACKNOWLEDGE（1）：GuestOS发现了这个设备，并且认为这是一个有效的virtio设备；</li>
<li>DRIVER (2) : GuestOS知道该如何驱动这个设备；</li>
<li>FAILED (128) : GuestOS无法正常驱动这个设备，Something is wrong；</li>
<li>FEATURES_OK (8) : GuestOS认识所有的feature，并且feature协商一完成；</li>
<li>DRIVER_OK (4) : 驱动加载完成，设备可以投入使用了；</li>
<li>DEVICE_NEEDS_RESET (64) ：设备触发了错误，需要重置才能继续工作。</li>
</ul>
<p><code>feature bits</code>用来标志设备支持那个特性，其中bit0-bit23是特定设备可以使用的<code>feature bits</code>，
bit24-bit37预给队列和feature协商机制，bit38以上保留给未来其他用途。
例如：对于virtio-net设备而言，feature bit0表示网卡设备支持checksum校验。
<code>VIRTIO_F_VERSION_1</code>这个feature bit用来表示设备是否支持virtio 1.0 spec标准。</p>
<p>在virtio协议中，所有的设备都使用virtqueue来进行数据的传输。
 <strong>每个设备可以有0个或者多个virtqueue，每个virtqueue占用2个或者更多个4K的物理页</strong>。
 virtqueue有<code>Split Virtqueues</code>和<code>Packed Virtqueues</code>两种模式，
 在<code>Split virtqueues</code>模式下virtqueue被分成若干个部分，
 每个部分都是前端驱动或者后端单向可写的（不能两端同时写）。
 每个virtqueue都有一个16bit的queue size参数，表示队列的总长度。
 每个virtqueue由3个部分组成：</p>
<div class="highlight"><pre><span></span><code><span class="c">    </span><span class="nb">+-------------------+--------------------------------+-----------------------+</span>
<span class="c">    | Descriptor Table  |   Available Ring  (padding)    |       Used Ring       |</span>
<span class="c">    </span><span class="nb">+-------------------+--------------------------------+-----------------------+</span>
</code></pre></div>

<ul>
<li>Descriptor Table：存放IO传输请求信息；</li>
<li>Available Ring：记录了Descriptor Table表中的I/O请求下发信息，前端Driver可写后端只读；</li>
<li>Used Ring：记录Descriptor Table表中已被提交到硬件的信息，前端Driver只读后端可写。</li>
</ul>
<p>整个virtio协议中设备IO请求的工作机制可以简单地概括为：</p>
<ol>
<li>前端驱动将IO请求放到<code>Descriptor Table</code>中，然后将索引更新到<code>Available Ring</code>中，最后kick后端去取数据；</li>
<li>后端取出IO请求进行处理，然后将结果刷新到<code>Descriptor Table</code>中再更新<code>Using Ring</code>，然后发送中断notify前端。</li>
</ol>
<p>从virtio协议可以了解到<strong>virtio设备支持3种设备呈现模式</strong>：</p>
<ul>
<li>Virtio Over PCI BUS，依旧遵循PCI规范，挂在到PCI总线上，作为virtio-pci设备呈现；</li>
<li>Virtio Over MMIO，部分不支持PCI协议的虚拟化平台可以使用这种工作模式，直接挂载到系统总线上；</li>
<li>Virtio Over Channel I/O：主要用在s390平台上，virtio-ccw使用这种基于channel I/O的机制。</li>
</ul>
<p>其中，Virtio Over PCI BUS的使用比较广泛，作为PCI设备需按照规范要通过PCI配置空间来向操作系统报告设备支持的特性集合，
这样操作系统才知道这是一个什么类型的virtio设备，并调用对应的前端驱动和这个设备进行握手，进而将设备驱动起来。
QEMU会给virtio设备模拟PCI配置空间，对于virtio设备来说PCI Vendor ID固定为0x1AF4，
PCI Device ID 为 0x1000到0x107F之间的是virtio设备。
同时，在不支持PCI协议的虚拟化平台上，virtio设备也可以直接通过MMIO进行呈现，
virtio-spec 4.2 <a href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html#x1-1440002">Virtio Over MMIO</a>有针对virtio-mmio设备呈现方式的详细描述，mmio相关信息可以直接通过内核参数报告给Linux操作系统。
本文主要基于virtio-pci展开讨论。</p>
<p>前面提到virtio设备有<code>feature bits</code>，<code>virtqueue</code>等四要素，那么在virtio-pci模式下是如何呈现的呢？
从virtio spec来看，老的virtio协议和新的virtio协议在这一块有很大改动。
virtio legacy（virtio 0.95）协议规定，对应的配置数据结构（virtio common configuration structure）
应该存放在设备的BAR0里面，我们称之为<code>virtio legay interface</code>，其结构如下：</p>
<div class="highlight"><pre><span></span><code><span class="c">                       virtio legacy ==</span><span class="nv">&gt;</span><span class="c"> Mapped into PCI BAR0 </span>
<span class="c">    </span><span class="nb">+------------------------------------------------------------------+</span><span class="c"> </span>
<span class="c">    |                    Host Feature Bits</span><span class="k">[</span><span class="c">0:31</span><span class="k">]</span><span class="c">                       | </span>
<span class="c">    </span><span class="nb">+------------------------------------------------------------------+</span>
<span class="c">    |                    Guest Feature Bits</span><span class="k">[</span><span class="c">0:31</span><span class="k">]</span><span class="c">                      |</span>
<span class="c">    </span><span class="nb">+------------------------------------------------------------------+</span>
<span class="c">    |                    Virtqueue Address PFN                         |</span>
<span class="c">    </span><span class="nb">+---------------------------------+--------------------------------+</span>
<span class="c">    |           Queue Select          |           Queue Size           |</span>
<span class="c">    </span><span class="nb">+----------------+----------------+--------------------------------+</span>
<span class="c">    |   ISR Status   | Device Stat    |           Queue Notify         |</span>
<span class="c">    </span><span class="nb">+----------------+----------------+--------------------------------+</span>
<span class="c">    |       MSI Config Vector         |         MSI Queue Vector       |</span>
<span class="c">    </span><span class="nb">+---------------------------------+--------------------------------+</span>
</code></pre></div>

<p>对于新的<code>virtio modern</code>，协议将配置结构划分为5种类型：</p>
<div class="highlight"><pre><span></span><code><span class="o">/*</span><span class="w"> </span><span class="n">Common</span><span class="w"> </span><span class="n">configuration</span><span class="w"> </span><span class="o">*/</span><span class="w"> </span>
#<span class="n">define</span><span class="w"> </span><span class="n">VIRTIO_PCI_CAP_COMMON_CFG</span><span class="w">        </span><span class="mi">1</span><span class="w"> </span>
<span class="o">/*</span><span class="w"> </span><span class="n">Notifications</span><span class="w"> </span><span class="o">*/</span><span class="w"> </span>
#<span class="n">define</span><span class="w"> </span><span class="n">VIRTIO_PCI_CAP_NOTIFY_CFG</span><span class="w">        </span><span class="mi">2</span>
<span class="o">/*</span><span class="w"> </span><span class="n">ISR</span><span class="w"> </span><span class="n">Status</span><span class="w"> </span><span class="o">*/</span><span class="w"> </span>
#<span class="n">define</span><span class="w"> </span><span class="n">VIRTIO_PCI_CAP_ISR_CFG</span><span class="w">           </span><span class="mi">3</span><span class="w"> </span>
<span class="o">/*</span><span class="w"> </span><span class="n">Device</span><span class="w"> </span><span class="n">specific</span><span class="w"> </span><span class="n">configuration</span><span class="w"> </span><span class="o">*/</span><span class="w"> </span>
#<span class="n">define</span><span class="w"> </span><span class="n">VIRTIO_PCI_CAP_DEVICE_CFG</span><span class="w">        </span><span class="mi">4</span><span class="w"> </span>
<span class="o">/*</span><span class="w"> </span><span class="n">PCI</span><span class="w"> </span><span class="n">configuration</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="o">*/</span><span class="w"> </span>
#<span class="n">define</span><span class="w"> </span><span class="n">VIRTIO_PCI_CAP_PCI_CFG</span><span class="w">           </span><span class="mi">5</span><span class="w"> </span>
</code></pre></div>

<p>以上的每种配置结构是直接映射到virtio设备的BAR空间内，那么如何指定每种配置结构的位置呢？
答案是通过<code>PCI Capability list</code>方式去指定，这和物理PCI设备是一样的，体现了virtio-pci的协议兼容性。</p>
<div class="highlight"><pre><span></span><code><span class="nx">struct</span><span class="w"> </span><span class="nx">virtio_pci_cap</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="kt">u8</span><span class="w"> </span><span class="nx">cap_vndr</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Generic PCI field: PCI_CAP_ID_VNDR */</span><span class="w"> </span>
<span class="w">        </span><span class="kt">u8</span><span class="w"> </span><span class="nx">cap_next</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Generic PCI field: next ptr. */</span><span class="w"> </span>
<span class="w">        </span><span class="kt">u8</span><span class="w"> </span><span class="nx">cap_len</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Generic PCI field: capability length */</span><span class="w"> </span>
<span class="w">        </span><span class="kt">u8</span><span class="w"> </span><span class="nx">cfg_type</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Identifies the structure. */</span><span class="w"> </span>
<span class="w">        </span><span class="kt">u8</span><span class="w"> </span><span class="nx">bar</span><span class="p">;</span><span class="w">         </span><span class="cm">/* Where to find it. */</span><span class="w"> </span>
<span class="w">        </span><span class="kt">u8</span><span class="w"> </span><span class="nx">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w">  </span><span class="cm">/* Pad to full dword. */</span><span class="w"> </span>
<span class="w">        </span><span class="nx">le32</span><span class="w"> </span><span class="nx">offset</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Offset within bar. */</span><span class="w"> </span>
<span class="w">        </span><span class="nx">le32</span><span class="w"> </span><span class="nx">length</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Length of the structure, in bytes. */</span><span class="w"> </span>
<span class="p">};</span>
</code></pre></div>

<p>只是略微不同的是，virtio-pci的Capability有一个统一的结构，
其中<code>cfg_type</code>表示Cap的类型，<code>bar</code>表示这个配置结构被映射到的BAR空间号。
这样每个配置结构都可以通过BAR空间直接访问，或者通过PCI配置空间的<code>VIRTIO_PCI_CAP_PCI_CFG</code>域进行访问。
每个Cap的具体结构定义可以参考virtio spec 4.1.4.3小节。
为了方便理解这里以一张virtio-net网卡为例：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@localhost ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">lspci</span><span class="w"> </span><span class="o">-</span><span class="n">vvvs</span><span class="w"> </span><span class="mi">04</span><span class="err">:</span><span class="mf">00.0</span>
<span class="mi">04</span><span class="err">:</span><span class="mf">00.0</span><span class="w"> </span><span class="n">Ethernet</span><span class="w"> </span><span class="nl">controller</span><span class="p">:</span><span class="w"> </span><span class="n">Red</span><span class="w"> </span><span class="n">Hat</span><span class="p">,</span><span class="w"> </span><span class="n">Inc</span><span class="p">.</span><span class="w"> </span><span class="n">Virtio</span><span class="w"> </span><span class="n">network</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="p">(</span><span class="n">rev</span><span class="w"> </span><span class="mi">01</span><span class="p">)</span>
<span class="w">    </span><span class="nl">Subsystem</span><span class="p">:</span><span class="w"> </span><span class="n">Red</span><span class="w"> </span><span class="n">Hat</span><span class="p">,</span><span class="w"> </span><span class="n">Inc</span><span class="p">.</span><span class="w"> </span><span class="n">Device</span><span class="w"> </span><span class="mi">1100</span>
<span class="w">    </span><span class="n">Physical</span><span class="w"> </span><span class="nl">Slot</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="nl">Control</span><span class="p">:</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="o">+</span><span class="w"> </span><span class="n">Mem</span><span class="o">+</span><span class="w"> </span><span class="n">BusMaster</span><span class="o">+</span><span class="w"> </span><span class="n">SpecCycle</span><span class="o">-</span><span class="w"> </span><span class="n">MemWINV</span><span class="o">-</span><span class="w"> </span><span class="n">VGASnoop</span><span class="o">-</span><span class="w"> </span><span class="n">ParErr</span><span class="o">-</span><span class="w"> </span><span class="n">Stepping</span><span class="o">-</span><span class="w"> </span><span class="n">SERR</span><span class="o">+</span><span class="w"> </span><span class="n">FastB2B</span><span class="o">-</span><span class="w"> </span><span class="n">DisINTx</span><span class="o">+</span>
<span class="w">    </span><span class="nl">Status</span><span class="p">:</span><span class="w"> </span><span class="n">Cap</span><span class="o">+</span><span class="w"> </span><span class="mi">66</span><span class="n">MHz</span><span class="o">-</span><span class="w"> </span><span class="n">UDF</span><span class="o">-</span><span class="w"> </span><span class="n">FastB2B</span><span class="o">-</span><span class="w"> </span><span class="n">ParErr</span><span class="o">-</span><span class="w"> </span><span class="n">DEVSEL</span><span class="o">=</span><span class="n">fast</span><span class="w"> </span><span class="o">&gt;</span><span class="n">TAbort</span><span class="o">-</span><span class="w"> </span><span class="o">&lt;</span><span class="n">TAbort</span><span class="o">-</span><span class="w"> </span><span class="o">&lt;</span><span class="n">MAbort</span><span class="o">-</span><span class="w"> </span><span class="o">&gt;</span><span class="n">SERR</span><span class="o">-</span><span class="w"> </span><span class="o">&lt;</span><span class="n">PERR</span><span class="o">-</span><span class="w"> </span><span class="n">INTx</span><span class="o">-</span>
<span class="w">    </span><span class="nl">Latency</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="nl">Interrupt</span><span class="p">:</span><span class="w"> </span><span class="n">pin</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">routed</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">IRQ</span><span class="w"> </span><span class="mi">21</span>
<span class="w">    </span><span class="n">Region</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="n">Memory</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">fe840000</span><span class="w"> </span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="nc">bit</span><span class="p">,</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">prefetchable</span><span class="p">)</span><span class="w"> </span><span class="o">[</span><span class="n">size=4K</span><span class="o">]</span>
<span class="w">    </span><span class="n">Region</span><span class="w"> </span><span class="mi">4</span><span class="err">:</span><span class="w"> </span><span class="n">Memory</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">fa600000</span><span class="w"> </span><span class="p">(</span><span class="mi">64</span><span class="o">-</span><span class="nc">bit</span><span class="p">,</span><span class="w"> </span><span class="n">prefetchable</span><span class="p">)</span><span class="w"> </span><span class="o">[</span><span class="n">size=16K</span><span class="o">]</span>
<span class="w">    </span><span class="n">Expansion</span><span class="w"> </span><span class="n">ROM</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">fe800000</span><span class="w"> </span><span class="o">[</span><span class="n">disabled</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">size=256K</span><span class="o">]</span>
<span class="w">    </span><span class="nl">Capabilities</span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="n">dc</span><span class="o">]</span><span class="w"> </span><span class="n">MSI</span><span class="o">-</span><span class="nl">X</span><span class="p">:</span><span class="w"> </span><span class="n">Enable</span><span class="o">+</span><span class="w"> </span><span class="nf">Count</span><span class="o">=</span><span class="mi">10</span><span class="w"> </span><span class="n">Masked</span><span class="o">-</span>
<span class="w">        </span><span class="n">Vector</span><span class="w"> </span><span class="nc">table</span><span class="err">:</span><span class="w"> </span><span class="n">BAR</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="mi">00000000</span>
<span class="w">        </span><span class="nl">PBA</span><span class="p">:</span><span class="w"> </span><span class="n">BAR</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="mi">00000800</span>
<span class="w">    </span><span class="nl">Capabilities</span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="n">c8</span><span class="o">]</span><span class="w"> </span><span class="n">Vendor</span><span class="w"> </span><span class="k">Specific</span><span class="w"> </span><span class="nl">Information</span><span class="p">:</span><span class="w"> </span><span class="nl">VirtIO</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="k">unknown</span><span class="o">&gt;</span>
<span class="w">        </span><span class="n">BAR</span><span class="o">=</span><span class="mi">0</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="mi">00000000</span><span class="w"> </span><span class="k">size</span><span class="o">=</span><span class="mi">00000000</span>
<span class="w">    </span><span class="nl">Capabilities</span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="n">b4</span><span class="o">]</span><span class="w"> </span><span class="n">Vendor</span><span class="w"> </span><span class="k">Specific</span><span class="w"> </span><span class="nl">Information</span><span class="p">:</span><span class="w"> </span><span class="nl">VirtIO</span><span class="p">:</span><span class="w"> </span><span class="n">Notify</span>
<span class="w">        </span><span class="n">BAR</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="mi">00003000</span><span class="w"> </span><span class="k">size</span><span class="o">=</span><span class="mi">00001000</span><span class="w"> </span><span class="n">multiplier</span><span class="o">=</span><span class="mi">00000004</span>
<span class="w">    </span><span class="nl">Capabilities</span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="n">a4</span><span class="o">]</span><span class="w"> </span><span class="n">Vendor</span><span class="w"> </span><span class="k">Specific</span><span class="w"> </span><span class="nl">Information</span><span class="p">:</span><span class="w"> </span><span class="nl">VirtIO</span><span class="p">:</span><span class="w"> </span><span class="n">DeviceCfg</span>
<span class="w">        </span><span class="n">BAR</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="mi">00002000</span><span class="w"> </span><span class="k">size</span><span class="o">=</span><span class="mi">00001000</span>
<span class="w">    </span><span class="nl">Capabilities</span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="n">94</span><span class="o">]</span><span class="w"> </span><span class="n">Vendor</span><span class="w"> </span><span class="k">Specific</span><span class="w"> </span><span class="nl">Information</span><span class="p">:</span><span class="w"> </span><span class="nl">VirtIO</span><span class="p">:</span><span class="w"> </span><span class="n">ISR</span>
<span class="w">        </span><span class="n">BAR</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="mi">00001000</span><span class="w"> </span><span class="k">size</span><span class="o">=</span><span class="mi">00001000</span>
<span class="w">    </span><span class="nl">Capabilities</span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="n">84</span><span class="o">]</span><span class="w"> </span><span class="n">Vendor</span><span class="w"> </span><span class="k">Specific</span><span class="w"> </span><span class="nl">Information</span><span class="p">:</span><span class="w"> </span><span class="nl">VirtIO</span><span class="p">:</span><span class="w"> </span><span class="n">CommonCfg</span>
<span class="w">        </span><span class="n">BAR</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">offset</span><span class="o">=</span><span class="mi">00000000</span><span class="w"> </span><span class="k">size</span><span class="o">=</span><span class="mi">00001000</span>
</code></pre></div>

<p>MSI-X的vector table和PBA放到了BAR1里面，
BAR4里放了common cfg，设备isr状态信息，device cfg，driver notify信息等。</p>
<h1>1. 前后端数据共享</h1>
<p>传统的纯模拟设备在工作的时候，会触发频繁的陷入陷出，
而且IO请求的内容要进行多次拷贝传递，严重影响了设备的IO性能。
virtio为了提升设备的IO性能，采用了共享内存机制，
<strong><em>前端驱动会提前申请好一段物理地址空间用来存放IO请求，然后将这段地址的GPA告诉QEMU</em></strong>。
前端驱动在下发IO请求后，QEMU可以直接从共享内存中取出请求，然后将完成后的结果又直接写到虚拟机对应地址上去。
<strong>整个过程中可以做到直投直取，省去了不必要的数据拷贝开销</strong>。</p>
<p><strong><code>Virtqueue</code>是整个virtio方案的灵魂所在</strong>。每个virtqueue都包含3张表，
<code>Descriptor Table</code>存放了IO请求描述符，<code>Available Ring</code>记录了当前哪些描述符是可用的，
<code>Used Ring</code>记录了哪些描述符已经被后端使用了。</p>
<div class="highlight"><pre><span></span><code>                          +------------------------------------+
                          |       virtio  guest driver         |
                          +-----------------+------------------+
                            /               |              ^
                           /                |               \
                          put            update             get
                         /                  |                 \
                        V                   V                  \
                   +----------+      +------------+        +----------+
                   |          |      |            |        |          |
                   +----------+      +------------+        +----------+
                   | available|      | descriptor |        |   used   |
                   |   ring   |      |   table    |        |   ring   |
                   +----------+      +------------+        +----------+
                   |          |      |            |        |          |
                   +----------+      +------------+        +----------+
                   |          |      |            |        |          |
                   +----------+      +------------+        +----------+
                        \                   ^                   ^
                         \                  |                  /
                         get             update              put
                           \                |                /
                            V               |               /
                           +----------------+-------------------+
                           |       virtio host backend          |
                           +------------------------------------+
</code></pre></div>

<p><code>Desriptor Table</code>中存放的是一个一个的<code>virtq_desc</code>元素，每个<code>virq_desc</code>元素占用16个字节。</p>
<div class="highlight"><pre><span></span><code><span class="nb">+-----------------------------------------------------------+</span>
<span class="c">|                        addr/gpa </span><span class="k">[</span><span class="c">0:63</span><span class="k">]</span><span class="c">                    |</span>
<span class="nb">+-------------------------+-----------------+---------------+</span>
<span class="c">|         len </span><span class="k">[</span><span class="c">0:31</span><span class="k">]</span><span class="c">      |  flags </span><span class="k">[</span><span class="c">0:15</span><span class="k">]</span><span class="c">   |  next </span><span class="k">[</span><span class="c">0:15</span><span class="k">]</span><span class="c">  |</span>
<span class="nb">+-------------------------+-----------------+---------------+</span>
</code></pre></div>

<p>其中，addr占用64bit存放了单个IO请求的GPA地址信息，例如addr可能表示某个DMA buffer的起始地址。
len占用32bit表示IO请求的长度，flags的取值有3种，
<code>VIRTQ_DESC_F_NEXT</code>表示这个IO请求和下一个<code>virtq_desc</code>描述的是连续的，
<code>IRTQ_DESC_F_WRITE</code>表示这段buffer是write only的，
<code>VIRTQ_DESC_F_INDIRECT</code>表示这段buffer里面放的内容是另外一组buffer的<code>virtq_desc</code>（相当于重定向），
next是指向下一个<code>virtq_desc</code>的索引号（前提是<code>VIRTQ_DESC_F_NEXT</code> &amp; flags）。</p>
<p><code>Available Ring</code>是前端驱动用来告知后端那些IO buffer是的请求需要处理，每个Ring中包含一个<code>virtq_avail</code>占用8个字节。
其中，flags取值为<code>VIRTQ_AVAIL_F_NO_INTERRUPT</code>时表示前端驱动告诉后端：
“当你消耗完一个IO buffer的时候，不要立刻给我发中断”（防止中断过多影响效率）。
idx表示下次前端驱动要放置<code>Descriptor Entry</code>的地方。</p>
<div class="highlight"><pre><span></span><code><span class="nb">+--------------+-------------+--------------+---------------------+</span>
<span class="c">| flags </span><span class="k">[</span><span class="c">0:15</span><span class="k">]</span><span class="c"> |  idx </span><span class="k">[</span><span class="c">0:15</span><span class="k">]</span><span class="c"> |  ring</span><span class="k">[</span><span class="c">0:15</span><span class="k">]</span><span class="c">  |  used_event </span><span class="k">[</span><span class="c">0:15</span><span class="k">]</span><span class="c">  |</span>
<span class="nb">+--------------+-------------+--------------+---------------------+</span>
</code></pre></div>

<p>Used Ring结构稍微不一样，flags的值如果为<code>VIRTIO_F_EVENT_IDX</code>并且前后端协商<code>VIRTIO_F_EVENT_IDX</code> feature成功,
那么Guest会将used ring index放在available ring的末尾，告诉后端说：
“Hi 小老弟，当你处理完这个请求的时候，给我发个中断通知我一下”，
同时host也会将avail_event index放到used ring的末尾，告诉guest说：
“Hi 老兄，记得把这个idx的请求kick给我哈”。
<code>VIRTIO_F_EVENT_IDX</code>对virtio通知/中断有一定的优化，在某些场景下能够提升IO性能。</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* The Guest publishes the used index for which it expects an interrupt</span>
<span class="cm"> * at the end of the avail ring. Host should ignore the avail-&gt;flags field. */</span>
<span class="cm">/* The Host publishes the avail index for which it expects a kick</span>
<span class="cm"> * at the end of the used ring. Guest should ignore the used-&gt;flags field. */</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">virtq_used</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="cp">#define VIRTQ_USED_F_NO_NOTIFY  1 </span>
<span class="w">        </span><span class="n">le16</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="n">le16</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">virtq_used_elem</span><span class="w"> </span><span class="n">ring</span><span class="p">[</span><span class="w"> </span><span class="cm">/* Queue Size */</span><span class="p">];</span><span class="w"> </span>
<span class="w">        </span><span class="n">le16</span><span class="w"> </span><span class="n">avail_event</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Only if VIRTIO_F_EVENT_IDX */</span><span class="w"> </span>
<span class="p">};</span><span class="w"> </span>

<span class="cm">/* le32 is used here for ids for padding reasons. */</span><span class="w"> </span>
<span class="k">struct</span><span class="w"> </span><span class="nc">virtq_used_elem</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="cm">/* Index of start of used descriptor chain. */</span><span class="w"> </span>
<span class="w">        </span><span class="n">le32</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="cm">/* Total length of the descriptor chain which was used (written to) */</span><span class="w"> </span>
<span class="w">        </span><span class="n">le32</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span>
<span class="p">};</span>
</code></pre></div>

<p>原理就到这里，后面会以virtio网卡为例进行详细流程说明。</p>
<h2>2. 前后端通信机制（irqfd 与 ioeventfd）</h2>
<p>共享内存方式解决了传统设备IO过程中内存拷贝带来的性能损耗问题，除此之外前端驱动和后端驱动的通信问题也是有可以改进的地方。
Virtio前后端通信概括起来只有两个方向，即GuestOS通知QEMU和QEMU通知GuestOS。
当前端驱动准备好IO buffer之后，需要通知后端（QEMU），告诉后端：
“小老弟，我有一波IO请求已经准备好了，你帮我处理一下”。
前端通知出去后，就可以等待IO结果了（操作系统可以进行一次调度），这时候vCPU可以去干点其他的事情。
后端收到消息后开始处理IO请求，当IO请求处理完成之后，后端就通过中断机制通知GuestOS：
“老哥，你的IO给你处理好了，你来取一下”。
前后端通信机制如下图所示：</p>
<div class="highlight"><pre><span></span><code>             +-------------+                +-------------+
             |             |                |             |
             |             |                |             |
             |   GuestOS   |                |     QEMU    |
             |             |                |             |
             |             |                |             |
             +---+---------+                +----+--------+
                 |     ^                         |    ^
                 |     |                         |    |
             +---|-----|-------------------------|----|---+
             |   |     |                irqfd    |    |   |
             |   |     +-------------------------+    |   |
             |   |  ioeventfd                         |   |
             |   +------------------------------------+   |
             |                   KVM                      |
             +--------------------------------------------+
</code></pre></div>

<p>前端驱动通知后端比较简单，QEMU设置一段特定的MMIO地址空间，前端驱动访问这段MMIO触发VMExit，
退出到KVM后利用<code>ioeventfd</code>机制通知到用户态的QEMU，QEMU主循环（main_loop poll）
检测到ioeventfd事件后调用callback进行处理。</p>
<div class="highlight"><pre><span></span><code><span class="n">前端驱动通知后端</span><span class="err">：</span>
<span class="n">内核流程mark一下</span><span class="err">，</span><span class="n">PCI设备驱动流程这个后面可以学习一下</span><span class="err">，</span><span class="n">先扫描PCI</span><span class="w"> </span><span class="n">bus发现是virtio设备再扫描virtio</span><span class="o">-</span><span class="n">bus</span><span class="err">。</span>
<span class="n">worker_thread</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">process_one_work</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">pciehp_power_thread</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">pciehp_enable_slot</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span>
<span class="n">pciehp_configure_device</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">pci_bus_add_devices</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">pci_bus_add_device</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">device_attach</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span>
<span class="n">__device_attach</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">bus_for_each_drv</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">__device_attach_driver</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">driver_probe_device</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span>
<span class="n">pci_device_probe</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">local_pci_probe</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_pci_probe</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">register_virtio_device</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span>
<span class="n">device_register</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">device_add</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">bus_probe_device</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">device_initial_probe</span><span class="w"> </span>
<span class="o">--&gt;</span><span class="w"> </span><span class="n">__device_attach</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">bus_for_each_drv</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">__device_attach_driver</span><span class="w"> </span><span class="o">--&gt;</span>
<span class="n">driver_probe_device</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_dev_probe</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtnet_probe</span><span class="w"> </span><span class="p">(</span><span class="n">网卡设备驱动加载的入口</span><span class="p">)</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">virtnet_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">virtio_device</span><span class="w"> </span><span class="o">*</span><span class="n">vdev</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="p">......</span>
<span class="w">    </span><span class="n">virtio_device_ready</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * virtio_device_ready - enable vq use in probe function</span>
<span class="cm"> * @vdev: the device</span>
<span class="cm"> *</span>
<span class="cm"> * Driver must call this to use vqs in the probe function.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: vqs are enabled automatically after probe returns.</span>
<span class="cm"> */</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span>
<span class="kt">void</span><span class="w"> </span><span class="n">virtio_device_ready</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">virtio_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">get_status</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="w">        </span><span class="n">BUG_ON</span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VIRTIO_CONFIG_S_DRIVER_OK</span><span class="p">);</span>
<span class="w">        </span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">set_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VIRTIO_CONFIG_S_DRIVER_OK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp"># QEMU/KVM后端的处理流程如下：</span>
<span class="cp"># 前端驱动写Status位，val &amp; VIRTIO_CONFIG_S_DRIVER_OK，这时候前端驱动已经ready</span>
<span class="n">virtio_pci_config_write</span><span class="w">  </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_ioport_write</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_pci_start_ioeventfd</span>
<span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_bus_set_host_notifier</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_bus_start_ioeventfd</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_device_start_ioeventfd_impl</span>
<span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_bus_set_host_notifier</span>
<span class="w">    </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_pci_ioeventfd_assign</span>
<span class="w">        </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">memory_region_add_eventfd</span>
<span class="w">            </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">memory_region_transaction_commit</span>
<span class="w">              </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">address_space_update_ioeventfds</span>
<span class="w">                </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">address_space_add_del_ioeventfds</span>
<span class="w">                  </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">kvm_io_ioeventfd_add</span><span class="o">/</span><span class="n">vhost_eventfd_add</span>
<span class="w">                    </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">kvm_set_ioeventfd_pio</span>
<span class="w">                      </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">kvm_vm_ioctl</span><span class="p">(</span><span class="n">kvm_state</span><span class="p">,</span><span class="w"> </span><span class="n">KVM_IOEVENTFD</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">kick</span><span class="p">)</span>
</code></pre></div>

<p>其实，这就是QEMU的<code>Fast MMIO</code>实现机制。
我们可以看到，QEMU会为每个设备MMIO对应的MemoryRegion注册一个ioeventfd。
最后调用了一个KVM_IOEVENTFD ioctl到KVM内核里面，而在KVM内核中会将MMIO对应的（gpa,len,eventfd）信息会注册到KVM_FAST_MMIO_BUS上。
这样当Guest访问MMIO地址范围退出后（触发<code>EPT Misconfig</code>），KVM会查询一下访问的GPA是否落在某段MMIO地址空间range内部，
如果是的话就直接写eventfd告知QEMU，QEMU就会从coalesced mmio ring page中取MMIO请求
（注：pio page和 mmio page是QEMU和KVM内核之间的共享内存页，已经提前mmap好了）。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#kvm内核代码virt/kvm/eventfd.c中</span>
<span class="n">kvm_vm_ioctl</span><span class="p">(</span><span class="n">KVM_IOEVENTFD</span><span class="p">)</span>
<span class="w">  </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">kvm_ioeventfd</span>
<span class="w">    </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">kvm_assign_ioeventfd</span>
<span class="w">      </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">kvm_assign_ioeventfd_idx</span>

<span class="cp"># MMIO处理流程中（handle_ept_misconfig）最后会调用到ioeventfd_write通知QEMU。</span>
<span class="cm">/* MMIO/PIO writes trigger an event if the addr/val match */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="n">ioeventfd_write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kvm_vcpu</span><span class="w"> </span><span class="o">*</span><span class="n">vcpu</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kvm_io_device</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="n">gpa_t</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">_ioeventfd</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_ioeventfd</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ioeventfd_in_range</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">))</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

<span class="w">        </span><span class="n">eventfd_signal</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>不了解<code>MMIO</code>是如何模拟的童鞋，可以结合本站的文章<a href="https://kernelgo.org/mmio.html"><code>MMIO</code>模拟实现分析</a>去了解一下，
如果还是不懂的可以在文章下面评论。</p>
<p><strong>后端通知前端，是通过中断的方式</strong>，QEMU/KVM中有一套完整的中断模拟实现框架，</p>
<p>如果对QEMU/KVM中断模拟不熟悉的童鞋，
建议阅读一下这篇文章：<a href="https://www.binss.me/blog/qemu-note-of-interrupt/"><code>QEMU学习笔记-中断</code></a>。
对于virtio-pci设备，可以通过Cap呈现MSIx给虚拟机，这样在前端驱动加载的时候就会尝试去使能MSIx中断，
后端在这个时候建立起MSIx通道。</p>
<p>前端驱动加载(probe)的过程中，会去初始化<code>virtqueue</code>，这个时候会去申请MSIx中断并注册中断处理函数：</p>
<div class="highlight"><pre><span></span><code><span class="n">virtnet_probe</span>
<span class="w">  </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">init_vqs</span>
<span class="w">    </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtnet_find_vqs</span>
<span class="w">      </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">find_vqs</span><span class="w"> </span><span class="p">[</span><span class="n">vp_modern_find_vqs</span><span class="p">]</span>
<span class="w">        </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">vp_find_vqs</span>
<span class="w">          </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">vp_find_vqs_msix</span><span class="w"> </span><span class="c1">// 为每virtqueue申请一个MSIx中断，通常收发各一个队列</span>
<span class="w">            </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">vp_request_msix_vectors</span><span class="w"> </span><span class="c1">// 主要的MSIx中断申请逻辑都在这个函数里面</span>
<span class="w">              </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">pci_alloc_irq_vectors_affinity</span><span class="w"> </span><span class="c1">// 申请MSIx中断描述符(__pci_enable_msix_range)</span>
<span class="w">                </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">request_irq</span><span class="w">  </span><span class="c1">// 注册中断处理函数</span>

<span class="w">           </span><span class="c1">// virtio-net网卡至少申请了3个MSIx中断：</span>
<span class="w">                </span><span class="c1">// 一个是configuration change中断（配置空间发生变化后，QEMU通知前端）</span>
<span class="w">                </span><span class="c1">// 发送队列1个MSIx中断，接收队列1MSIx中断</span>
</code></pre></div>

<p>在QEMU/KVM这一侧，开始模拟MSIx中断，具体流程大致如下：</p>
<div class="highlight"><pre><span></span><code><span class="n">virtio_pci_config_write</span>
<span class="w">  </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_ioport_write</span>
<span class="w">    </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_set_status</span>
<span class="w">      </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_net_vhost_status</span>
<span class="w">        </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">vhost_net_start</span>
<span class="w">          </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_pci_set_guest_notifiers</span>
<span class="w">            </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">kvm_virtio_pci_vector_use</span><span class="w"> </span>
<span class="w">              </span><span class="o">|--&gt;</span><span class="w"> </span><span class="n">kvm_irqchip_add_msi_route</span><span class="w"> </span><span class="c1">//更新中断路由表</span>
<span class="w">              </span><span class="o">|--&gt;</span><span class="w"> </span><span class="n">kvm_virtio_pci_irqfd_use</span><span class="w">  </span><span class="c1">//使能MSI中断</span>
<span class="w">                 </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">kvm_irqchip_add_irqfd_notifier_gsi</span>
<span class="w">                   </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">kvm_irqchip_assign_irqfd</span>

<span class="cp"># 申请MSIx中断的时候，会为MSIx分配一个gsi，并为这个gsi绑定一个irqfd，然后调用ioctl KVM_IRQFD注册到内核中。               </span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">kvm_irqchip_assign_irqfd</span><span class="p">(</span><span class="n">KVMState</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rfd</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">virq</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">bool</span><span class="w"> </span><span class="n">assign</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kvm_irqfd</span><span class="w"> </span><span class="n">irqfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">gsi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">virq</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assign</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">KVM_IRQFD_FLAG_DEASSIGN</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rfd</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">irqfd</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">KVM_IRQFD_FLAG_RESAMPLE</span><span class="p">;</span>
<span class="w">        </span><span class="n">irqfd</span><span class="p">.</span><span class="n">resamplefd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rfd</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">kvm_irqfds_enabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">kvm_vm_ioctl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">KVM_IRQFD</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">irqfd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp"># KVM内核代码virt/kvm/eventfd.c</span>
<span class="n">kvm_vm_ioctl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">KVM_IRQFD</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">irqfd</span><span class="p">)</span>
<span class="w">  </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">kvm_irqfd_assign</span>
<span class="w">    </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">vfs_poll</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">irqfd</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">)</span><span class="w"> </span><span class="c1">// 在内核中poll这个irqfd</span>
</code></pre></div>

<p>从上面的流程可以看出，<strong>QEMU/KVM使用<code>irqfd</code>机制来模拟MSIx中断</strong>，
即设备申请MSIx中断的时候会为MSIx分配一个gsi（这个时候会刷新irq routing table），
并为这个gsi绑定一个<code>irqfd</code>，最后在内核中去<code>poll</code>这个<code>irqfd</code>。
当QEMU处理完IO之后，就写MSIx对应的irqfd，给前端注入一个MSIx中断，告知前端我已经处理好IO了你可以来取结果了。</p>
<p>例如，virtio-scsi从前端取出IO请求后会取做DMA操作（DMA是异步的，QEMU协程中负责处理）。
当DMA完成后QEMU需要告知前端IO请求已完成（Complete），那么怎么去投递这个MSIx中断呢？
答案是调用<code>virtio_notify_irqfd</code>注入一个MSIx中断。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#0  0x00005604798d569b in virtio_notify_irqfd (vdev=0x56047d12d670, vq=0x7fab10006110) at  hw/virtio/virtio.c:1684</span>
<span class="cp">#1  0x00005604798adea4 in virtio_scsi_complete_req (req=0x56047d09fa70) at  hw/scsi/virtio-scsi.c:76</span>
<span class="cp">#2  0x00005604798aecfb in virtio_scsi_complete_cmd_req (req=0x56047d09fa70) at  hw/scsi/virtio-scsi.c:468</span>
<span class="cp">#3  0x00005604798aee9d in virtio_scsi_command_complete (r=0x56047ccb0be0, status=0, resid=0) at  hw/scsi/virtio-scsi.c:495</span>
<span class="cp">#4  0x0000560479b397cf in scsi_req_complete (req=0x56047ccb0be0, status=0) at hw/scsi/scsi-bus.c:1404</span>
<span class="cp">#5  0x0000560479b2b503 in scsi_dma_complete_noio (r=0x56047ccb0be0, ret=0) at hw/scsi/scsi-disk.c:279</span>
<span class="cp">#6  0x0000560479b2b610 in scsi_dma_complete (opaque=0x56047ccb0be0, ret=0) at hw/scsi/scsi-disk.c:300</span>
<span class="cp">#7  0x00005604799b89e3 in dma_complete (dbs=0x56047c6e9ab0, ret=0) at dma-helpers.c:118</span>
<span class="cp">#8  0x00005604799b8a90 in dma_blk_cb (opaque=0x56047c6e9ab0, ret=0) at dma-helpers.c:136</span>
<span class="cp">#9  0x0000560479cf5220 in blk_aio_complete (acb=0x56047cd77d40) at block/block-backend.c:1327</span>
<span class="cp">#10 0x0000560479cf5470 in blk_aio_read_entry (opaque=0x56047cd77d40) at block/block-backend.c:1387</span>
<span class="cp">#11 0x0000560479df49c4 in coroutine_trampoline (i0=2095821104, i1=22020) at util/coroutine-ucontext.c:115</span>
<span class="cp">#12 0x00007fab214d82c0 in __start_context () at /usr/lib64/libc.so.6</span>
</code></pre></div>

<p>在<code>virtio_notify_irqfd</code>函数中，会去写<code>irqfd</code>，给内核发送一个信号。</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">virtio_notify_irqfd</span><span class="p">(</span><span class="n">VirtIODevice</span><span class="w"> </span><span class="o">*</span><span class="n">vdev</span><span class="p">,</span><span class="w"> </span><span class="n">VirtQueue</span><span class="w"> </span><span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">     </span><span class="cm">/*</span>
<span class="cm">     * virtio spec 1.0 says ISR bit 0 should be ignored with MSI, but</span>
<span class="cm">     * windows drivers included in virtio-win 1.8.0 (circa 2015) are</span>
<span class="cm">     * incorrectly polling this bit during crashdump and hibernation</span>
<span class="cm">     * in MSI mode, causing a hang if this bit is never updated.</span>
<span class="cm">     * Recent releases of Windows do not really shut down, but rather</span>
<span class="cm">     * log out and hibernate to make the next startup faster.  Hence,</span>
<span class="cm">     * this manifested as a more serious hang during shutdown with</span>
<span class="cm">     *</span>
<span class="cm">     * Next driver release from 2016 fixed this problem, so working around it</span>
<span class="cm">     * is not a must, but it&#39;s easy to do so let&#39;s do it here.</span>
<span class="cm">     *</span>
<span class="cm">     * Note: it&#39;s safe to update ISR from any thread as it was switched</span>
<span class="cm">     * to an atomic operation.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">virtio_set_isr</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1</span><span class="p">);</span>
<span class="w">    </span><span class="n">event_notifier_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">guest_notifier</span><span class="p">);</span><span class="w">   </span><span class="c1">//写vq-&gt;guest_notifier，即irqfd</span>
<span class="p">}</span>
</code></pre></div>

<p>QEMU写了这个<code>irqfd</code>后，KVM内核模块中的irqfd poll就收到一个<code>POLL_IN</code>事件，然后将MSIx中断自动投递给对应的LAPIC。
大致流程是：<code>POLL_IN</code> -&gt; <code>kvm_arch_set_irq_inatomic</code> -&gt; <code>kvm_set_msi_irq</code>, <code>kvm_irq_delivery_to_apic_fast</code></p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">irqfd_wakeup</span><span class="p">(</span><span class="n">wait_queue_entry_t</span><span class="w"> </span><span class="o">*</span><span class="n">wait</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sync</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">EPOLLIN</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">irq_srcu</span><span class="p">);</span>
<span class="w">                </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irqfd</span><span class="o">-&gt;</span><span class="n">irq_entry_sc</span><span class="p">);</span>
<span class="w">                        </span><span class="n">irq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irqfd</span><span class="o">-&gt;</span><span class="n">irq_entry</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irqfd</span><span class="o">-&gt;</span><span class="n">irq_entry_sc</span><span class="p">,</span><span class="w"> </span><span class="n">seq</span><span class="p">));</span>
<span class="w">                </span><span class="cm">/* An event has been signaled, inject an interrupt */</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">kvm_arch_set_irq_inatomic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="n">kvm</span><span class="p">,</span>
<span class="w">                                             </span><span class="n">KVM_USERSPACE_IRQ_SOURCE_ID</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                                             </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">)</span>
<span class="w">                        </span><span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irqfd</span><span class="o">-&gt;</span><span class="n">inject</span><span class="p">);</span>
<span class="w">                </span><span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">irq_srcu</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
</code></pre></div>

<p>这里还有一点没有想明白，结合代码和调试来看，virtio-blk/virtio-scsi的msi中断走irqfd机制，
但是virtio-net（不开启vhost的情况下）不走irqfd，而是直接调用<code>virtio_notify</code>/<code>virtio_pci_notify</code>，
最后通过KVM的ioctl投递中断？
从代码路径上来看，后者明显路径更长，谁知道原因告诉我一下!!!。
https://patchwork.kernel.org/patch/9531577/</p>
<div class="highlight"><pre><span></span><code>Once in virtio_notify_irqfd, once in virtio_queue_guest_notifier_read.

Unfortunately, for virtio-blk + MSI + KVM + old Windows drivers we need the one in virtio_notify_irqfd.
For virtio-net + vhost + INTx we need the one in virtio_queue_guest_notifier_read. 
这显然路径更长啊。 
</code></pre></div>

<p>Ok，到这里virtio前后端通信机制已经明了，最后一个小节我们以virtio-net为例，梳理一下virtio中的部分核心代码流程。</p>
<h2>3. virtio核心代码分析，以virtio-net为例</h2>
<p>这里我们已virtio-net网卡为例，在没有使用vhost的情况下（网卡后端收发包都走QEMU处理），
后端收发包走vhost的情况下有些不同，后面单独分析。</p>
<h3>3.1 前后端握手流程</h3>
<p>QEM模拟PCI设备对GuestOS进行呈现，设备驱动加载的时候尝试去初始化设备。</p>
<div class="highlight"><pre><span></span><code><span class="cp"># 先在PCI总线上调用probe设备，调用了virtio_pci_probe，然后再virtio-bus上调用virtio_dev_probe</span>
<span class="cp"># virtio_dev_probe最后调用到virtnet_probe</span>
<span class="n">pci_device_probe</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">local_pci_probe</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtio_pci_probe</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">register_virtio_device</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span>
<span class="n">device_register</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">device_add</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">bus_probe_device</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">device_initial_probe</span><span class="w"> </span>
<span class="o">--&gt;</span><span class="w"> </span><span class="n">__device_attach</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">bus_for_each_drv</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">__device_attach_driver</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">driver_probe_device</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span>
<span class="n">virtio_dev_probe</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtnet_probe</span>

<span class="cp"># 在virtio_pci_probe里先尝试以virtio modern方式读取设备配置数据结构，如果失败则尝试virio legacy方式。</span>
<span class="cp"># 对于virtio legacy，我们前面提到了virtio legacy协议规定设备的配置数据结构放在PCI BAR0里面。</span>
<span class="cm">/* the PCI probing function */</span>
<span class="kt">int</span><span class="w"> </span><span class="n">virtio_pci_legacy_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">virtio_pci_device</span><span class="w"> </span><span class="o">*</span><span class="n">vp_dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pci_request_region</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;virtio-pci-legacy&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">//将设备的BAR0映射到物理地址空间</span>
<span class="w">        </span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pci_iomap</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">   </span><span class="c1">//获得BAR0的内核地址</span>
<span class="p">}</span>

<span class="cp">#对于virtio modern，通过capability方式报告配置数据结构的位置，配置数据结构有5种类型。</span>
<span class="kt">int</span><span class="w"> </span><span class="n">virtio_pci_modern_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">virtio_pci_device</span><span class="w"> </span><span class="o">*</span><span class="n">vp_dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="cm">/* check for a common config: if not, use legacy mode (bar 0). */</span>
<span class="w">        </span><span class="n">common</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">virtio_pci_find_capability</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span><span class="w"> </span><span class="n">VIRTIO_PCI_CAP_COMMON_CFG</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">IORESOURCE_IO</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">IORESOURCE_MEM</span><span class="p">,</span>
<span class="w">                                            </span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">modern_bars</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* If common is there, these should be too... */</span>
<span class="w">        </span><span class="n">isr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">virtio_pci_find_capability</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span><span class="w"> </span><span class="n">VIRTIO_PCI_CAP_ISR_CFG</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">IORESOURCE_IO</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">IORESOURCE_MEM</span><span class="p">,</span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">modern_bars</span><span class="p">);</span>
<span class="w">        </span><span class="n">notify</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">virtio_pci_find_capability</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span><span class="w"> </span><span class="n">VIRTIO_PCI_CAP_NOTIFY_CFG</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">IORESOURCE_IO</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">IORESOURCE_MEM</span><span class="p">,</span>
<span class="w">                                            </span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">modern_bars</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Device capability is only mandatory for devices that have</span>
<span class="cm">        * device-specific configuration.</span>
<span class="cm">        */</span>
<span class="w">        </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">virtio_pci_find_capability</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span><span class="w"> </span><span class="n">VIRTIO_PCI_CAP_DEVICE_CFG</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">IORESOURCE_IO</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">IORESOURCE_MEM</span><span class="p">,</span>
<span class="w">                                            </span><span class="o">&amp;</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">modern_bars</span><span class="p">);</span>

<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pci_request_selected_regions</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span><span class="w"> </span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">modern_bars</span><span class="p">,</span>
<span class="w">                                            </span><span class="s">&quot;virtio-pci-modern&quot;</span><span class="p">);</span>
<span class="w">                                        </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">virtio_pci_common_cfg</span><span class="p">),</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">                                        </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">virtio_pci_common_cfg</span><span class="p">),</span>
<span class="w">                                        </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 将配virtio置结构所在的BAR空间MAP到内核地址空间里                                </span>
<span class="w">        </span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">common</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_capability</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span><span class="w"> </span><span class="n">common</span><span class="p">,</span>
<span class="w">                                        </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">virtio_pci_common_cfg</span><span class="p">),</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">                                        </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">virtio_pci_common_cfg</span><span class="p">),</span>
<span class="w">                                        </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">        </span><span class="p">......</span><span class="w">                              </span>
<span class="p">}</span>

<span class="cp"># 接着来到virtio_dev_probe里面看下：</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">virtio_dev_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">_d</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="cm">/* We have a driver! */</span>
<span class="w">        </span><span class="n">virtio_add_status</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">VIRTIO_CONFIG_S_DRIVER</span><span class="p">);</span><span class="w">     </span><span class="c1">// 更新status bit，这里要写配置数据结构</span>

<span class="w">        </span><span class="cm">/* Figure out what features the device supports. */</span>
<span class="w">        </span><span class="n">device_features</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">get_features</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span><span class="w">   </span><span class="c1">// 查询后端支持哪些feature bits</span>

<span class="w">        </span><span class="c1">// feature set协商，取交集</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">virtio_finalize_features</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span><span class="w"> </span>

<span class="w">        </span><span class="c1">// 调用特定virtio设备的驱动程序probe，例如: virtnet_probe, virtblk_probe</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>

<p>再看下<code>virtnet_probe</code>里面的一些关键的流程，这里包含了virtio-net网卡前端初始化的主要逻辑。</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">virtnet_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">virtio_device</span><span class="w"> </span><span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">       </span><span class="c1">// check后端是否支持多队列，并按情况创建队列</span>
<span class="w">       </span><span class="cm">/* Allocate ourselves a network device with room for our info */</span>
<span class="w">        </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_etherdev_mq</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">virtnet_info</span><span class="p">),</span><span class="w"> </span><span class="n">max_queue_pairs</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 定义一个网络设备并配置一些属性，例如MAC地址</span>
<span class="w">        </span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">virtnet_ethtool_ops</span><span class="p">;</span>
<span class="w">           </span><span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 初始化virtqueue</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">init_vqs</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 注册一个网络设备</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 写状态位DRIVER_OK，告诉后端，前端已经ready</span>
<span class="w">        </span><span class="n">virtio_device_ready</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 将网卡up起来</span>
<span class="w">        </span><span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>其中关键的流程是<code>init_vqs</code>，在<code>vp_find_vqs_msix</code>流程中会尝试去申请MSIx中断，这里前面已经有分析过了。
其中，"configuration changed" 中断服务程序<code>vp_config_changed</code>， 
virtqueue队列的中断服务程序是 <code>vp_vring_interrupt</code>。</p>
<div class="highlight"><pre><span></span><code><span class="n">init_vqs</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">virtnet_find_vqs</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">vi</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">find_vqs</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">vp_modern_find_vqs</span>
<span class="o">--&gt;</span><span class="w"> </span><span class="n">vp_find_vqs</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">vp_find_vqs_msix</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vp_find_vqs_msix</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">virtio_device</span><span class="w"> </span><span class="o">*</span><span class="n">vdev</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">nvqs</span><span class="p">,</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">virtqueue</span><span class="w"> </span><span class="o">*</span><span class="n">vqs</span><span class="p">[],</span><span class="w"> </span><span class="n">vq_callback_t</span><span class="w"> </span><span class="o">*</span><span class="n">callbacks</span><span class="p">[],</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">names</span><span class="p">[],</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">per_vq_vectors</span><span class="p">,</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">irq_affinity</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>


<span class="w">        </span><span class="c1">// 为每个vq分配一个MSIx中断号， per_vq_vectors = true</span>
<span class="w">        </span><span class="c1">// 同时为configuration change申请单独一个MSIx中断，一并设置了cfg的中断处理函数</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vp_request_msix_vectors</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span><span class="w"> </span><span class="n">nvectors</span><span class="p">,</span><span class="w"> </span><span class="n">per_vq_vectors</span><span class="p">,</span>
<span class="w">                  </span><span class="n">per_vq_vectors</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nvqs</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// 创建队列 --&gt; vring_create_virtqueue --&gt; vring_create_virtqueue_split --&gt; vring_alloc_queue</span>
<span class="w">                </span><span class="n">vqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vp_setup_vq</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span><span class="w"> </span><span class="n">queue_idx</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">callbacks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
<span class="w">                                </span><span class="n">ctx</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">ctx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                                </span><span class="n">msix_vec</span><span class="p">);</span>

<span class="w">                </span><span class="c1">// 每个队列设置对应的MSIx中断处理函数</span>
<span class="w">                </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request_irq</span><span class="p">(</span><span class="n">pci_irq_vector</span><span class="p">(</span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span><span class="w"> </span><span class="n">msix_vec</span><span class="p">),</span>
<span class="w">                                  </span><span class="n">vring_interrupt</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">vp_dev</span><span class="o">-&gt;</span><span class="n">msix_names</span><span class="p">[</span><span class="n">msix_vec</span><span class="p">],</span>
<span class="w">                                  </span><span class="n">vqs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<p><code>vp_setup_vq</code>流程再往下走就开始分配共享内存页，至此建立起共享内存通信通道。
值得注意的是一路传下来的callbacks参数其实传入了发送队列和接收队列的回调处理函数，
好家伙，从<code>virtnet_find_vqs</code>一路传递到了<code>__vring_new_virtqueue</code>中最终赋值给了<code>vq-&gt;vq.callback</code>。</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">virtqueue</span><span class="w"> </span><span class="o">*</span><span class="n">vring_create_virtqueue_split</span><span class="p">(</span>
<span class="w">        </span><span class="n">unsigned</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span>
<span class="w">        </span><span class="n">unsigned</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">num</span><span class="p">,</span>
<span class="w">        </span><span class="n">unsigned</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">vring_align</span><span class="p">,</span>
<span class="w">        </span><span class="n">struct</span><span class="w"> </span><span class="n">virtio_device</span><span class="w"> </span><span class="o">*</span><span class="n">vdev</span><span class="p">,</span>
<span class="w">        </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="n">weak_barriers</span><span class="p">,</span>
<span class="w">        </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="n">may_reduce_num</span><span class="p">,</span>
<span class="w">        </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="n">context</span><span class="p">,</span>
<span class="w">        </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">notify</span><span class="p">)(</span><span class="n">struct</span><span class="w"> </span><span class="n">virtqueue</span><span class="w"> </span><span class="o">*</span><span class="p">),</span>
<span class="w">        </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="n">struct</span><span class="w"> </span><span class="n">virtqueue</span><span class="w"> </span><span class="o">*</span><span class="p">),</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="nb">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">       </span><span class="o">/*</span><span class="w"> </span><span class="n">TODO</span><span class="p">:</span><span class="w"> </span><span class="n">allocate</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="n">chunk</span><span class="w"> </span><span class="n">individually</span><span class="w"> </span><span class="o">*/</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">vring_size</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="n">vring_align</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="err">申请物理页，地址赋值给</span><span class="n">queue</span>
<span class="w">                </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vring_alloc_queue</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span><span class="w"> </span><span class="n">vring_size</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="n">vring_align</span><span class="p">),</span>
<span class="w">                                          </span><span class="o">&amp;</span><span class="n">dma_addr</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">__GFP_NOWARN</span><span class="o">|</span><span class="n">__GFP_ZERO</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>


<span class="w">        </span><span class="n">queue_size_in_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vring_size</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="n">vring_align</span><span class="p">);</span>
<span class="w">        </span><span class="n">vring_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vring</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="n">vring_align</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="err">确定</span><span class="w"> </span><span class="n">descriptor</span><span class="w"> </span><span class="n">table</span><span class="p">,</span><span class="w"> </span><span class="n">available</span><span class="w"> </span><span class="n">ring</span><span class="p">,</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">ring的位置</span><span class="err">。</span>
<span class="p">}</span>
</code></pre></div>

<p>我们看下如果<code>virtqueue</code>队列如果收到MSIx中断消息后，会调用哪个<code>hook</code>来处理？</p>
<div class="highlight"><pre><span></span><code><span class="n">irqreturn_t</span><span class="w"> </span><span class="nf">vring_interrupt</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">_vq</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">vring_virtqueue</span><span class="w"> </span><span class="o">*</span><span class="n">vq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_vvq</span><span class="p">(</span><span class="n">_vq</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">more_used</span><span class="p">(</span><span class="n">vq</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;virtqueue interrupt with no work for %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vq</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">broken</span><span class="p">))</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span>

<span class="w">        </span><span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;virtqueue callback for %p (%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vq</span><span class="p">,</span><span class="w"> </span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vq</span><span class="p">.</span><span class="n">callback</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vq</span><span class="p">.</span><span class="n">callback</span><span class="p">)</span>
<span class="w">                </span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vq</span><span class="p">.</span><span class="n">callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">vq</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vring_interrupt</span><span class="p">);</span>
</code></pre></div>

<p>不难想到中断服务程序里面会调用队列上的callback。
我们再回过头来看下<code>virtnet_find_vqs</code>，原来接受队列的回调函数是<code>skb_recv_done</code>，发送队列的回调函数是<code>skb_xmit_done</code>。</p>
<div class="highlight"><pre><span></span><code>static int virtnet_find_vqs(struct virtnet_info <span class="gs">*vi)</span>
<span class="gs">{</span>
<span class="gs">       /*</span> Allocate/initialize parameters for send/receive virtqueues */
        for (i = 0; i &lt; vi-&gt;max_queue_pairs; i++) {
        callbacks[rxq2vq(i)] = skb_recv_done;
        callbacks[txq2vq(i)] = skb_xmit_done;
    }
}
</code></pre></div>

<p>OK，这个小节就到这里。Are you clear ?</p>
<h3>3.2 virtio-net网卡收发在virtqueue上的实现</h3>
<p>这里以virtio-net为例（非vhost-net模式）来分析一下网卡收发报文在virtio协议上的具体实现。
virtio-net模式下网卡收发包的流程为： </p>
<ul>
<li>收包：Hardware =&gt; Host Kernel =&gt; Qemu =&gt; Guest</li>
<li>发包：Guest =&gt; Host Kernel =&gt; Qemu =&gt; Host Kernel =&gt; Hardware</li>
</ul>
<h4>3.2.1 virtio-net网卡发包</h4>
<p>前面我们看到virtio-net设备初始化的时候会创建一个<code>net_device</code>设备：
<code>virtnet_probe</code> -&gt; <code>alloc_etherdev_mq</code>注册了<code>netdev_ops</code> = <code>&amp;virtnet_netdev</code>，
这里<code>virtnet_netdev</code>是网卡驱动的回调函数集合（收发包和参数设置）。</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">net_device_ops</span><span class="w"> </span><span class="n">netdev_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">ndo_open</span><span class="w">               </span><span class="o">=</span><span class="w"> </span><span class="n">rio_open</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ndo_start_xmit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_xmit</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ndo_stop</span><span class="w">               </span><span class="o">=</span><span class="w"> </span><span class="n">rio_close</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ndo_get_stats</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">get_stats</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ndo_validate_addr</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">eth_validate_addr</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ndo_set_mac_address</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">eth_mac_addr</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ndo_set_rx_mode</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">set_multicast</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ndo_do_ioctl</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">rio_ioctl</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ndo_tx_timeout</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">rio_tx_timeout</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>

<p>网卡发包的时候调用<code>ndo_start_xmit</code>，将TCP/IP上层协议栈扔下来的数据发送出去。
对应到virtio网卡的回调函数就是<code>start_xmit</code>，从代码看就是将skb发送到virtqueue中，
然后调用virtqueue_kick通知qemu后端将数据包发送出去。</p>
<p>Guest内核里面的virtio-net驱动发包：</p>
<div class="highlight"><pre><span></span><code><span class="n">内核驱动</span><span class="w"> </span><span class="n">virtio_net</span><span class="p">.</span><span class="n">c</span>
<span class="n">start_xmit</span>
<span class="w">    </span><span class="c1">// 将skb放到virtqueue队列中</span>
<span class="w">    </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">xmit_skb</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">sg_init_table</span><span class="p">,</span><span class="n">virtqueue_add_outbuf</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">virtqueue_add</span>
<span class="w">    </span><span class="c1">// kick通知qemu后端去取</span>
<span class="w">    </span><span class="n">virtqueue_kick_prepare</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">virtqueue_notify</span><span class="w"> </span>
<span class="w">    </span><span class="c1">// kick次数加1</span>
<span class="w">    </span><span class="n">sq</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">kicks</span><span class="o">++</span>
</code></pre></div>

<p>Guest Kick后端从KVM中VMExit出来退出到Qemu用户态（走的是ioeventfd）由Qemu去将数据发送出去。
大致调用的流程是：
<code>virtio_queue_host_notifier_read</code> -&gt; <code>virtio_net_handle_tx_bh</code> -&gt; <code>virtio_net_flush_tx</code>
-&gt; <code>virtqueue_pop</code>拿到发包(skb) -&gt; <code>qemu_sendv_packet_async</code></p>
<div class="highlight"><pre><span></span><code><span class="n">Qemu代码virtio</span><span class="o">-</span><span class="n">net相关代码</span><span class="o">:</span>
<span class="n">virtio_queue_host_notifier_read</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">virtio_queue_notify_vq</span>
<span class="w">    </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">vq</span><span class="o">-&gt;</span><span class="n">handle_output</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">virtio_net_handle_tx_bh</span><span class="w"> </span><span class="n">队列注册的时候</span><span class="err">，</span><span class="n">回注册回调函数</span>
<span class="w">        </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">qemu_bh_schedule</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">virtio_net_tx_bh</span>
<span class="w">            </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">virtio_net_flush_tx</span>
<span class="w">            </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">virtqueue_pop</span>
<span class="w">        </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">qemu_sendv_packet_async</span><span class="w"> </span><span class="c1">// 报文放到发送队列上，写tap设备的fd去发包</span>
<span class="w">            </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tap_receive_iov</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tap_write_packet</span>

<span class="c1">// 最后调用 tap_write_packet 把数据包发给tap设备投递出去</span>
</code></pre></div>

<h4>3.2.2 virtio-net网卡收包</h4>
<p>网卡收包的时候，tap设备先收到报文，对应的virtio-net网卡tap设备fd变为可读，
Qemu主循环收到POLL_IN事件调用回调函数收包。</p>
<div class="highlight"><pre><span></span><code><span class="n">tap_send</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">qemu_send_packet_async</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">qemu_send_packet_async_with_flags</span>
<span class="w">    </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">qemu_net_queue_send</span>
<span class="w">        </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">qemu_net_queue_deliver</span>
<span class="w">        </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">qemu_deliver_packet_iov</span>
<span class="w">            </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">nc_sendv_compat</span>
<span class="w">            </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">virtio_net_receive</span>
<span class="w">                </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">virtio_net_receive_rcu</span>
</code></pre></div>

<p>virtio-net网卡收报最终调用了<code>virtio_net_receive_rcu</code>，
和发包类似都是调用<code>virtqueue_pop</code>从前端获取virtqueue element，
将报文数据填充到vring中然后<code>virtio_notify</code>注入中断通知前端驱动取结果。</p>
<p>这里不得不吐槽一下，为啥收包函数取名要叫<code>tap_send</code>。</p>
<h2>4. 参考文献</h2>
<ol>
<li><a href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html">virtio spec v1.1 </a></li>
<li><a href="https://ozlabs.org/~rusty/virtio-spec/virtio-paper.pdf">Towards a De-Facto Standard For Virtual</a></li>
<li>https://github.com/qemu/qemu/blob/master/hw/net/virtio-net.c</li>
<li>https://github.com/torvalds/linux/blob/master/drivers/net/virtio_net.c</li>
</ol>


             
 
                <p id="post-share-links">
    Share on:
      <a href="https://twitter.com/intent/tweet?text=Virtio%20Spec%20Overview&url=https%3A//kernelgo.org/virtio-overview.html&hashtags=virtualization,virtio,virtio-net,virtio-scsi,virtio-blk,virtqueue" target="_blank" rel="nofollow noopener noreferrer" title="Share on Twitter">Twitter</a>
 ❄       <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A//kernelgo.org/virtio-overview.html" target="_blank" rel="nofollow noopener noreferrer" title="Share on Facebook">Facebook</a>
 ❄       <a href="mailto:?subject=Virtio%20Spec%20Overview&amp;body=https%3A//kernelgo.org/virtio-overview.html" target="_blank" rel="nofollow noopener noreferrer" title="Share via Email">Email</a>

            
            







<section>
    <h6 style="display:none;">Comments</h6>
    <p id="comment-message"> </p>

    <div class="accordion" id="accordion2">
        <div class="accordion-group">
            <div class="accordion-heading">
                <a class="accordion-toggle disqus-comment-count comment-count collapsed"
                   data-toggle="collapse"
                   data-parent="#accordion2"
                   data-disqus-identifier="https://kernelgo.org/virtio-overview.html"
                   href="https://kernelgo.org/virtio-overview.html#comment_thread"
                   id="comment-accordion-toggle">
                    Comments
                </a>
            </div>
            <div id="comment_thread" class="accordion-body collapse">
                <div class="accordion-inner">
                    <div class="comments">
                        <div id="disqus_thread"></div>
                        <script>
    var disqus_shortname = 'kernelgo';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());

    var disqus_identifier = 'https://kernelgo.org/virtio-overview.html';
    var disqus_url = 'https://kernelgo.org/virtio-overview.html';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>




                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

            <hr/>
<section>
    <h2>Related Posts</h2>
<ul class="related-posts-list">
<li><a href="https://kernelgo.org/x86-nmi.html" title="Virt NMI Emulation">Virt NMI Emulation</a></li>
<li><a href="https://kernelgo.org/reading2019.html" title="Article Archive 2019 Reading Plan">Article Archive 2019 Reading Plan</a></li>
<li><a href="https://kernelgo.org/microVM.html" title="Lightweight Micro Virtual Machines">Lightweight Micro Virtual Machines</a></li>
<li><a href="https://kernelgo.org/reading2020.html" title="Article Archive 2020 Reading Plan">Article Archive 2020 Reading Plan</a></li>
<li><a href="https://kernelgo.org/amd-x2avic.html" title="AMD x2avic details">AMD x2avic details</a></li>
</ul>
<hr />
</section>
            <aside>
            <nav>
            <ul class="articles-timeline">
                <li class="previous-article">« <a href="https://kernelgo.org/armv8-virt-guide.html" title="Previous: ARMv8 Virtualization Overview">ARMv8 Virtualization Overview</a></li>
                <li class="next-article"><a href="https://kernelgo.org/vfio-mdev.html" title="Next: VFIO Mediated Devices Introduction">VFIO Mediated Devices Introduction</a> »</li>
            </ul>
            </nav>
            </aside>
        </div>
        <section id="article-sidebar" class="span2">
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2019-09-13T23:00:00+08:00">Fri 13 September 2019</time>

            <h4>Category</h4>
            <a class="category-link" href="https://kernelgo.org/categories.html#virtualization-ref">virtualization</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://kernelgo.org/tags.html#virtio-ref">virtio
                    <span class="superscript">1</span>
</a></li>
                <li><a href="https://kernelgo.org/tags.html#virtio-blk-ref">virtio-blk
                    <span class="superscript">1</span>
</a></li>
                <li><a href="https://kernelgo.org/tags.html#virtio-net-ref">virtio-net
                    <span class="superscript">1</span>
</a></li>
                <li><a href="https://kernelgo.org/tags.html#virtio-scsi-ref">virtio-scsi
                    <span class="superscript">1</span>
</a></li>
                <li><a href="https://kernelgo.org/tags.html#virtqueue-ref">virtqueue
                    <span class="superscript">1</span>
</a></li>
                <li><a href="https://kernelgo.org/tags.html#virtualization-ref">virtualization
                    <span class="superscript">16</span>
</a></li>
            </ul>
<h4>Contact</h4>
<div id="sidebar-social-link">
    <a href="https://github.com/fangying" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="GitHub" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1B1817"/><path fill="#fff" d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
    </a>
</div>
            





            





        </section>
</div>
</article>
<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides.
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>                    </div>
                    <div class="span1"></div>
                </div>
            </div>
        </div>
<footer>
    <div>
        <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title"> kernelgo"</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://kernelgo.org" property="cc:attributionName" rel="cc:attributionURL">Yori Fang</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </div>




    <div id="fpowered">
        Powered by: <a href="http://getpelican.com/" title="Pelican Home Page" target="_blank" rel="nofollow noopener noreferrer">Pelican</a>
        Theme: <a href="https://elegant.oncrashreboot.com/" title="Theme Elegant Home Page" target="_blank" rel="nofollow noopener noreferrer">Elegant</a>
    </div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script src="https://kernelgo.org/theme/js/elegant.prod.9e9d5ce754.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    <script>
    (function () {
        if (window.location.hash.match(/^#comment-\d+$/)) {
            $('#comment_thread').collapse('show');
        }
    })();
    window.onhashchange=function(){
        if (window.location.hash.match(/^#comment-\d+$/))
            window.location.reload(true);
    }
    $('#comment_thread').on('shown', function () {
        var link = document.getElementById('comment-accordion-toggle');
        var old_innerHTML = link.innerHTML;
        $(link).fadeOut(200, function() {
            $(this).text('Click here to hide comments').fadeIn(200);
        });
        $('#comment_thread').on('hidden', function () {
            $(link).fadeOut(200, function() {
                $(this).text(old_innerHTML).fadeIn(200);
            });
        })
    })
</script>

    </body>
    <!-- Theme: Elegant built for Pelican
        License : MIT -->
</html>