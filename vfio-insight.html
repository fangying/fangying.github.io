<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://blog.kernel.love/theme/css/style.min.css?2fcac227">

        <link rel="dns-prefetch" href="//fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>

        <meta name="author" content="Yori Fang" />

        <meta name="description" content="VFIO Insight Into VFIO
" />
        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="virtualization, virt, " />

<meta property="og:title" content="VFIO关键技术点分析 "/>
<meta property="og:url" content="https://blog.kernel.love/vfio-insight.html" />
<meta property="og:description" content="VFIO Insight Into VFIO" />
<meta property="og:site_name" content="blog.kernel.love" />
<meta property="og:article:author" content="Yori Fang" />
<meta property="og:article:published_time" content="2018-05-28T23:00:00+08:00" />
<meta property="og:article:modified_time" content="2018-05-28T23:00:00+08:00" />
<meta name="twitter:title" content="VFIO关键技术点分析 ">
<meta name="twitter:description" content="VFIO Insight Into VFIO">

        <title>VFIO关键技术点分析  · blog.kernel.love
</title>

<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-107392039-2', 'auto');
    ga('send', 'pageview');
</script>


    </head>
    <body>
        <div id="content">
            <div class="navbar navbar-static-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="https://blog.kernel.love/"><span class=site-name>blog.kernel.love</span></a>
                        <div class="nav-collapse collapse">
                            <ul class="nav pull-right top-menu">
                                <li >
                                    <a href=
                                       https://blog.kernel.love
                                    >Home</a>
                                </li>
                                <li ><a href="https://blog.kernel.love/pages/about.html">About</a></li>
                                <li ><a href="https://blog.kernel.love/categories.html">Categories</a></li>
                                <li ><a href="https://blog.kernel.love/tags.html">Tags</a></li>
                                <li ><a href="https://blog.kernel.love/archives.html">Archives</a></li>
                                <li><form class="navbar-search" action="https://blog.kernel.love/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container-fluid">
                <div class="row-fluid">
                    <div class="span1"></div>
                    <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
        <h1>
            <a href="https://blog.kernel.love/vfio-insight.html">
                VFIO关键技术点分析
            </a>
        </h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">
            
            <p>本文则主要探讨一下VFIO实现中的关键点，主要包括：</p>
<ul>
<li>VFIO中如实现对直通设备的I/O地址空间访问的？</li>
<li>VFIO中如何实现MSI/MSI-X，Interrupt Remapping，以及Posted Interrupt的支持？</li>
<li>VFIO中是如何建立DMA Remapping映射关系？</li>
<li>VFIO中又是如何支持设备热插拔的？</li>
</ul>
<p>上面4个问题你能回答上来吗？</p>
<hr>
<h3>1.VFIO中如实现对直通设备的I/O地址空间访问？</h3>
<p>在设备直通的场景下guest OS到底该如何访问设备I/O空间？
有两种方法可选：</p>
<p>方法A：直接呈现，将设备在主机上的PCI BAR呈现给guest，并通过VMCS的I/O bitmap和EPT页表使guest访问设备的PIO和MMIO都不引起VM-Exit，这样guest驱动程序可以直接访问设备的I/O地址空间。</p>
<p>方法B：建立转换表，呈现虚拟的PCI BAR给guest，当guest访问到虚拟机的I/O地址空间时VMM截获操作并通过转换表将I/O请求转发到设备在主机上的I/O地址空间上。</p>
<p>方法A看起来很高效，因为直接呈现的方式下不引入VM-Exit，但实际上是有问题的！
<strong>原因是</strong>：
设备的PCI BAR空间是由host的BIOS配置并由host操作系统直接使用的，
guest的PCI BAR空间是由guest的虚拟BIOS（例如Seabios）配置的，
那么问题来了，到底该由谁来配置设备的PCI BAR空间呢？肯定不能两个都生效否则就打架了！
我们应该阻止guest来修改真实设备的PCI BAR地址以防止造成host上PCI设备的BAR空间冲突导致可能出现的严重后果。</p>
<p>所以我们要选择方案B，建立转换表，明白这一点很重要！</p>
<p>对于直通设备的PIO访问而言，通过设置VMCS的I/O bitmap控制guest访问退出到VMM中然后通过转换表（模拟的方式）将PIO操作转发到真实物理设备上。对于MMIO的访问，可以通过EPT方式将虚拟的MMIO地址空间映射到物理设备的MMIO地址空间上，这样guest访问MMIO时并不需要VM-Exit。</p>
<p><strong>直通设备的PCI Config Space模拟</strong></p>
<p>PCI配置空间是用来报告设备I/O信息的区域，可以通过PIO或者MMIO方式进行访问。
设备直通场景的配置空间并不直接呈现给guest而是由VFIO配合qemu进行模拟的。</p>
<p>vfio_realize函数中，
QEMU会读取物理设备的PCI配置空间以此为基础然后对配置空间做些改动然后呈现给虚拟机。</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cm">/* Get a copy of config space */</span><span class="w">  </span><span class="c1">// 读取设备的原始PCI Config Space信息</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pread</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">vbasedev</span><span class="p">.</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">.</span><span class="n">config</span><span class="p">,</span>
<span class="w">                </span><span class="n">MIN</span><span class="p">(</span><span class="n">pci_config_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">),</span><span class="w"> </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">config_size</span><span class="p">),</span>
<span class="w">                </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">config_offset</span><span class="p">);</span><span class="w">   </span><span class="c1">// 调用vfio-pci内核中的vfio_pci_read实现</span>
<span class="w">    </span><span class="p">......</span><span class="w">              </span>
<span class="w">    </span><span class="cm">/* vfio emulates a lot for us, but some bits need extra love */</span>
<span class="w">    </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">emulated_config_bits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_malloc0</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">config_size</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 我们可以选择性的Enable/Disable一些Capability</span>
<span class="w">    </span><span class="cm">/* QEMU can choose to expose the ROM or not */</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">emulated_config_bits</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PCI_ROM_ADDRESS</span><span class="p">,</span><span class="w"> </span><span class="mh">0xff</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* QEMU can also add or extend BARs */</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">emulated_config_bits</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PCI_BASE_ADDRESS_0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xff</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 调用vfio_add_emulated_word修改模拟的PCI配置空间信息</span>
<span class="w">    </span><span class="n">vfio_add_emulated_word</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Clear host resource mapping info.  If we choose not to register a</span>
<span class="cm">     * BAR, such as might be the case with the option ROM, we can get</span>
<span class="cm">     * confusing, unwritable, residual addresses from the host here.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">.</span><span class="n">config</span><span class="p">[</span><span class="n">PCI_BASE_ADDRESS_0</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">.</span><span class="n">config</span><span class="p">[</span><span class="n">PCI_ROM_ADDRESS</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="n">vfio_bars_prepare</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span><span class="w">    </span><span class="c1">// 重点分析</span>
<span class="w">    </span><span class="n">vfio_bars_register</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span><span class="w">   </span><span class="c1">// 重点分析</span>
<span class="w">    </span><span class="n">vfio_add_capabilities</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span><span class="w"> </span><span class="n">errp</span><span class="p">);</span>
</code></pre></div>

<p>通常MSI/MSIX等信息都需要被QEMU修改，因为这些都是QEMU使用VFIO去模拟的。</p>
<p><strong>直通设备MMIO（BAR空间）映射</strong></p>
<p>vfio_realize函数中会对直通设备的MMIO空间进行映射，大致包含以下几个步骤:</p>
<ul>
<li>调用vfio_populate_device从VFIO中查询出设备的BAR空间信息</li>
<li>把设备的MMIO（BAR空间）重映射（mmap）到QEMU进程的虚拟地址空间</li>
<li>将该段虚拟机地址空间标记为RAM类型注册给虚拟机</li>
</ul>
<p>这样一来，guest访问MMIO地址空间时直接通过EPT翻译到HPA不需要VM-Exit。我们分析下具体流程：</p>
<div class="highlight"><pre><span></span><code><span class="n">vfio_realize</span>
<span class="w">    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_populate_device</span>
<span class="w">            </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_region_setup</span><span class="w">  </span>
<span class="w">                    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_get_region_info</span><span class="w">   </span><span class="c1">// call ioct VFIO_DEVICE_GET_REGION_INFO</span>
<span class="w">                    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">memory_region_init_io</span><span class="w">  </span><span class="c1">// init region-&gt;mem MR as I/O</span>
<span class="w">    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_bars_prepare</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">vfio_bar_prepare</span><span class="w">  </span><span class="c1">// probe info of each pci bar from PCI cfg space</span>
<span class="w">    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_bars_register</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">vfio_bar_register</span>
<span class="w">            </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">memory_region_init_io</span><span class="w"> </span><span class="c1">// int bar-&gt;mr</span>
<span class="w">            </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">memory_region_add_subregion</span><span class="w"> </span><span class="c1">// add bar-&gt;mr into region-&gt;mem MR</span>
<span class="w">            </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_region_mmap</span>
<span class="w">                </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">mmap</span><span class="w"> </span><span class="c1">// map device bar space into QEMU process address space -&gt; iova</span>
<span class="w">                </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">memory_region_init_ram_device_ptr</span><span class="w"> </span><span class="c1">// register iova into VM  physical AS</span>
<span class="w">                </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">memory_region_add_subregion</span><span class="w"> </span><span class="c1">// add region-&gt;mmaps[i].mem into region-&gt;mem MR</span>
<span class="w">            </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">pci_register_bar</span>
</code></pre></div>

<p>为了方便理解这个过程，我画了一张示意图：</p>
<p><img alt="vfio-pci-bar" src="../images/vfio_pci_bar.svg"></p>
<p>QEMU首先调用vfio_region_mmap，
通过mmap region-&gt;vbasedev-&gt;fd 把设备MMIO映射到QEMU进程的虚拟地址空间，
这实际上通过调用vfio-pci内核驱动vfio_pci_mmap -&gt; remap_pfn_range，
<em>remap_pfn_range</em>是内核提供的API，
可以将一段连续的物理地址空间映射到进程的虚拟地址空间，
这里用它将设备的BAR空间的MMIO先映射到QEMU进程的虚拟地址空间再注册给虚拟机。</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">vfio_pci_mmap</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">device_data</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">vm_area_struct</span><span class="w"> </span><span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">req_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span><span class="w">     </span><span class="c1">// MMIO size</span>
<span class="w">    </span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">PAGE_SHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pgoff</span><span class="p">;</span><span class="w">  </span><span class="c1">// MMIO page address </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">remap_pfn_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span><span class="w"> </span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span><span class="w"> </span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">,</span>
<span class="w">            </span><span class="n">req_len</span><span class="p">,</span><span class="w"> </span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div>

<p>再来看下QEMU是如何注册这段虚拟地址(IOVA)到虚拟机的。</p>
<p>vfio_region_mmap调用memory_region_init_ram_device_ptr把前面mmap过来的
这段IOVA作为RAM类型设备注册给虚拟机。</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">vfio_region_mmap</span><span class="p">(</span><span class="n">VFIORegion</span><span class="w"> </span><span class="o">*</span><span class="n">region</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_strdup_printf</span><span class="p">(</span><span class="s">&quot;%s mmaps[%d]&quot;</span><span class="p">,</span>
<span class="w">                               </span><span class="n">memory_region_name</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">memory_region_init_ram_device_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">mmaps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">memory_region_owner</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">),</span>
<span class="w">                                        </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">region</span><span class="o">-&gt;</span><span class="n">mmaps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">region</span><span class="o">-&gt;</span><span class="n">mmaps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mmap</span><span class="p">);</span>
<span class="w">    </span><span class="n">memory_region_add_subregion</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">region</span><span class="o">-&gt;</span><span class="n">mmaps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">,</span>
<span class="w">                                </span><span class="o">&amp;</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">mmaps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mem</span><span class="p">);</span><span class="w">                                    </span>
<span class="p">}</span>
</code></pre></div>

<p>memory_region_init_ram_device_ptr中会标志 mr-&gt;ram = true，
那么QEMU就会通过kvm_set_phys_mem注册这段内存给虚拟机（是RAM类型才会建立EPT映射关系），
这样KVM就会为这段地址空间建立EPT页表，
虚拟机访问设备的MMIO空间时通过EPT页表翻直接访问不需要VM-Exit。
例如，网卡的收发包场景，虚拟机可以直接操作真实网卡的相关寄存器（MMIO映射）而没有陷入先出开销，大幅度提升了虚拟化场景下的I/O性能。</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">kvm_set_phys_mem</span><span class="p">(</span><span class="n">KVMMemoryListener</span><span class="w"> </span><span class="o">*</span><span class="n">kml</span><span class="p">,</span>
<span class="w">                             </span><span class="n">MemoryRegionSection</span><span class="w"> </span><span class="o">*</span><span class="n">section</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">add</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">memory_region_is_ram</span><span class="p">(</span><span class="n">mr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// mr-&gt;ram = true 会注册到KVM</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">writeable</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">kvm_readonly_mem_allowed</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mr</span><span class="o">-&gt;</span><span class="n">romd_mode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* If the memory device is not in romd_mode, then we actually want</span>
<span class="cm">             * to remove the kvm memory slot so all accesses will trap. */</span>
<span class="w">            </span><span class="n">add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">ram</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_region_get_ram_ptr</span><span class="p">(</span><span class="n">mr</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">   </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_region</span><span class="w"> </span><span class="o">+</span><span class="w">  </span>
<span class="w">          </span><span class="p">(</span><span class="n">start_addr</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_address_space</span><span class="p">);</span>
<span class="w">    </span><span class="n">kvm_set_user_memory_region</span><span class="w">  </span><span class="c1">// 作为RAM设备注册到KVM中</span>
<span class="p">}</span>
</code></pre></div>

<h3>2.VFIO中如何实现MSI/MSI-X，Interrupt Remapping，以及Posted Interrupt的支持？</h3>
<p>对于VFIO设备直通而言，设备中断的处理方式共有4种:</p>
<ul>
<li>INTx 最传统的PCI设备引脚Pin方式</li>
<li>MSI/MSI-X方式</li>
<li>Interrupt Remapping方式</li>
<li>VT-d Posted Interrupt方式</li>
</ul>
<p>那么它们分别是如何设计实现的呢？
这里我们来重点探索一下MSI/MSI-X的实现方式以及VT-d Posted Interrupt方式。
如果忘了MSI和MSI-X的知识点可以看下《<a href="https://www.xilinx.com/Attachment/PCI_SPEV_V3_0.pdf">PCI Local Bus Specification 
 Revision 3.0</a>》的Chapter 6有比较详细的介绍。</p>
<p>先看下QEMU这边中断初始化和中断使能相关的函数调用关系图：</p>
<div class="highlight"><pre><span></span><code><span class="n">vfio_realize</span>
<span class="w">    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_get_device</span><span class="w">       </span><span class="c1">// get device info: num_irqs, num_regions, flags</span>
<span class="w">    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_msix_early_setup</span><span class="w"> </span><span class="c1">// get MSI-X info: table_bar,table_offset, pba_ -&gt; pci_device_route_intx_to_irqbar,pba_offset, entries</span>
<span class="w">        </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_pci_fixup_msix_region</span>
<span class="w">        </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_pci_relocate_msix</span>
<span class="w">    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_add_capabilities</span>
<span class="w">            </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_add_std_cap</span>
<span class="w">                </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_msi_setup</span><span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">msi_init</span>
<span class="w">                </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_msix_setup</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">msix_init</span>
<span class="w">    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_intx_enable</span><span class="w">    </span><span class="c1">// enable intx</span>
<span class="w">        </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">pci_device_route_intx_to_irq</span>
<span class="w">        </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">event_notifier_init</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">intx</span><span class="p">.</span><span class="n">interrupt</span>
<span class="w">        </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">ioctl</span><span class="w"> </span><span class="n">VFIO_DEVICE_SET_IRQS</span>

<span class="n">kvm_cpu_exec</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_pci_write_config</span>
<span class="w">            </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_msi_enable</span><span class="w"> </span>
<span class="w">                    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">event_notifier_init</span><span class="w">        </span><span class="c1">// init eventfd as irqfd</span>
<span class="w">                    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_add_kvm_msi_virq</span><span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">kvm_irqchip_assign_irqfd</span>
<span class="w">                    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_enable_vectors</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span>
<span class="w">            </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_msix_enable</span>
<span class="w">                </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_msix_vector_do_use</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">msix_vector_use</span>
<span class="w">                </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_msix_vector_release</span>
<span class="w">                </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">msix_set_vector_notifiers</span>
</code></pre></div>

<p>从图中可以看出，直通设备初始化时候会从物理设备的PCI配置空间读取INTx、MSI、MSI-X的相关信息并且进行一些必要的初始化（setup）再进行中断使能（enable）的。
根据调试的结果来看，INTx的enable是最早的，
而MSI/MSI-X初始化是在guest启动后进行enable。</p>
<p>这里以MSI-X为例，
首先调用vfio_msix_early_setup函数从硬件设备的PCI配置空间查询MSI-X相关信息包括:</p>
<ul>
<li>MSI-X Table Size ：MSI-X Table 大小</li>
<li>MSI-X Table BAR Indicator ：MSI-X Table存放的BAR空间编号</li>
<li>MSI-X Table Offset ：存放MSI-X Table在Table BAR空间中的偏移量</li>
<li>MSI-X PBA BIR ：存放MSI-X 的Pending Bit Array的BAR空间编号</li>
<li>MSI-X PBA Offset ：存放MSI-X Table在PBA BAR空间中的偏移量</li>
</ul>
<p>获取必要信息之后，通过vfio_msix_setup来完成直通设备的MSI-X的初始化工作，
包括调用pci_add_capability为设备添加PCI_CAP_ID_MSIX Capability，
并注册MSI-X的BAR空间到虚拟机的物理地址空间等。</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">vfio_msix_early_setup</span><span class="p">(</span><span class="n">VFIOPCIDevice</span><span class="w"> </span><span class="o">*</span><span class="n">vdev</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">**</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pread</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ctrl</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ctrl</span><span class="p">),</span>
<span class="w">              </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">config_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PCI_MSIX_FLAGS</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ctrl</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">error_setg_errno</span><span class="p">(</span><span class="n">errp</span><span class="p">,</span><span class="w"> </span><span class="n">errno</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;failed to read PCI MSIX FLAGS&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pread</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">table</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">table</span><span class="p">),</span>
<span class="w">              </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">config_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PCI_MSIX_TABLE</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">table</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">error_setg_errno</span><span class="p">(</span><span class="n">errp</span><span class="p">,</span><span class="w"> </span><span class="n">errno</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;failed to read PCI MSIX TABLE&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pread</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pba</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">pba</span><span class="p">),</span>
<span class="w">              </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">config_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PCI_MSIX_PBA</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">pba</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">error_setg_errno</span><span class="p">(</span><span class="n">errp</span><span class="p">,</span><span class="w"> </span><span class="n">errno</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;failed to read PCI MSIX PBA&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">ctrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ctrl</span><span class="p">);</span>
<span class="w">    </span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="w">    </span><span class="n">pba</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pba</span><span class="p">);</span>

<span class="w">    </span><span class="n">msix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_malloc0</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">msix</span><span class="p">));</span>
<span class="w">    </span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">table_bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PCI_MSIX_FLAGS_BIRMASK</span><span class="p">;</span>
<span class="w">    </span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">table_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">PCI_MSIX_FLAGS_BIRMASK</span><span class="p">;</span>
<span class="w">    </span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">pba_bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pba</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PCI_MSIX_FLAGS_BIRMASK</span><span class="p">;</span>
<span class="w">    </span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">pba_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pba</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">PCI_MSIX_FLAGS_BIRMASK</span><span class="p">;</span>
<span class="w">    </span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ctrl</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PCI_MSIX_FLAGS_QSIZE</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">vfio_msix_setup</span><span class="p">(</span><span class="n">VFIOPCIDevice</span><span class="w"> </span><span class="o">*</span><span class="n">vdev</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">**</span><span class="n">errp</span><span class="p">)</span>
<span class="p">{</span>

<span class="w">    </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">pending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_malloc0</span><span class="p">(</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                                    </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">));</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msix_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span><span class="w"> </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span>
<span class="w">                    </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">bars</span><span class="p">[</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">table_bar</span><span class="p">].</span><span class="n">mr</span><span class="p">,</span>
<span class="w">                    </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">table_bar</span><span class="p">,</span><span class="w"> </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">table_offset</span><span class="p">,</span>
<span class="w">                    </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">bars</span><span class="p">[</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">pba_bar</span><span class="p">].</span><span class="n">mr</span><span class="p">,</span>
<span class="w">                    </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">pba_bar</span><span class="p">,</span><span class="w"> </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">msix</span><span class="o">-&gt;</span><span class="n">pba_offset</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span>
<span class="w">                    </span><span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="n">memory_region_set_enabled</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">.</span><span class="n">msix_pba_mmio</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">object_property_get_bool</span><span class="p">(</span><span class="n">OBJECT</span><span class="p">(</span><span class="n">qdev_get_machine</span><span class="p">()),</span>
<span class="w">                                 </span><span class="s">&quot;vfio-no-msix-emulation&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory_region_set_enabled</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">.</span><span class="n">msix_table_mmio</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>最后guest启动后调用vfio_msix_enable使能MSI-X中断。</p>
<h3>irqfd 和 ioeventfd</h3>
<p>我们知道QEMU本身有一套完整的模拟PCI设备INTx、MSI、MSI-X中断机制，
其实现方式是irqfd（QEMU中断注入到guest）和ioeventfd（guest中断通知到QEMU），
内部实现都是基于内核提供的eventfd机制。</p>
<p>看代码的时候一直没明白设备中断绑定的irqfd是在什么时候注册的，从代码上看不是中断enable时候。
后来结合代码调试才明白，
原来中断enable时候将设备的MSI/MSI-X BAR空间映射用MMIO方式注册给了虚拟机（参考msix_init, msi_init函数实现），
当虚拟机内部第一次访问MSI-X Table BAR空间的MMIO时会退出到用户态完成irqfd的注册，
调用堆栈为：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#0  kvm_irqchip_assign_irqfd</span>
<span class="cp">#1   in kvm_irqchip_add_irqfd_notifier_gsi </span>
<span class="cp">#2   in vfio_add_kvm_msi_virq </span>
<span class="cp">#3   in vfio_msix_vector_do_use </span>
<span class="cp">#4   in vfio_msix_vector_use </span>
<span class="cp">#5   in msix_fire_vector_notifier</span>
<span class="cp">#6   in msix_handle_mask_update </span>
<span class="cp">#7   in msix_table_mmio_write </span>
<span class="cp">#8   in memory_region_write_accessor</span>
<span class="cp">#9   in access_with_adjusted_size </span>
<span class="cp">#10  in memory_region_dispatch_write </span>
<span class="cp">#11  in address_space_write_continue </span>
<span class="cp">#12  in address_space_write </span>
<span class="cp">#13  in address_space_rw </span>
<span class="cp">#14  in kvm_cpu_exec </span>
</code></pre></div>

<p>关于irqfd的社区patch可以从这里获取<a href="https://lwn.net/Articles/332924/">https://lwn.net/Articles/332924</a>。</p>
<p>备注：Alex Williamson在最新的VFIO模块中加入新特性，支持直接使用物理设备的MSIX BAR空间，
这样一来可以直接将物理设备的MSI-X BAR空间直接mmap过来然后呈现给虚拟机，
guest直接使用而不用再进行模拟了。</p>
<div class="highlight"><pre><span></span><code><span class="k">commit</span><span class="w"> </span><span class="n">ae0215b2bb56a9d5321a185dde133bfdd306a4c0</span>
<span class="nl">Author</span><span class="p">:</span><span class="w"> </span><span class="n">Alexey</span><span class="w"> </span><span class="n">Kardashevskiy</span><span class="w"> </span><span class="o">&lt;</span><span class="n">aik</span><span class="nv">@ozlabs</span><span class="p">.</span><span class="n">ru</span><span class="o">&gt;</span>
<span class="nc">Date</span><span class="err">:</span><span class="w">   </span><span class="n">Tue</span><span class="w"> </span><span class="n">Mar</span><span class="w"> </span><span class="mi">13</span><span class="w"> </span><span class="mi">11</span><span class="err">:</span><span class="mi">17</span><span class="err">:</span><span class="mi">31</span><span class="w"> </span><span class="mi">2018</span><span class="w"> </span><span class="o">-</span><span class="mi">0600</span>

<span class="w">    </span><span class="n">vfio</span><span class="o">-</span><span class="nl">pci</span><span class="p">:</span><span class="w"> </span><span class="n">Allow</span><span class="w"> </span><span class="n">mmap</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">MSIX</span><span class="w"> </span><span class="n">BAR</span>

<span class="w">    </span><span class="k">At</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">moment</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">unconditionally</span><span class="w"> </span><span class="n">avoid</span><span class="w"> </span><span class="n">mapping</span><span class="w"> </span><span class="n">MSIX</span><span class="w"> </span><span class="k">data</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">BAR</span><span class="w"> </span><span class="ow">and</span>
<span class="w">    </span><span class="n">emulate</span><span class="w"> </span><span class="n">MSIX</span><span class="w"> </span><span class="nc">table</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">QEMU</span><span class="p">.</span><span class="w"> </span><span class="n">However</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">always</span><span class="w"> </span><span class="n">necessary</span><span class="w"> </span><span class="k">as</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="n">platform</span><span class="w"> </span><span class="n">may</span><span class="w"> </span><span class="n">provide</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">paravirt</span><span class="w"> </span><span class="n">interface</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MSIX</span><span class="w"> </span><span class="n">configuration</span><span class="p">;</span>
<span class="w">    </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">affect</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">speed</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">MMIO</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">emulating</span><span class="w"> </span><span class="n">them</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">QEMU</span><span class="w"> </span><span class="k">when</span>
<span class="w">    </span><span class="n">frequently</span><span class="w"> </span><span class="n">accessed</span><span class="w"> </span><span class="n">registers</span><span class="w"> </span><span class="n">share</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="k">system</span><span class="w"> </span><span class="n">page</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">MSIX</span><span class="w"> </span><span class="k">data</span><span class="p">,</span>
<span class="w">    </span><span class="n">this</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">particularly</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">problem</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">systems</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">page</span><span class="w"> </span><span class="k">size</span><span class="w"> </span><span class="n">bigger</span>
<span class="w">    </span><span class="k">than</span><span class="w"> </span><span class="mi">4</span><span class="n">KB</span><span class="p">.</span>

<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">capability</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">VFIO_REGION_INFO_CAP_MSIX_MAPPABLE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">added</span>
<span class="w">    </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">tells</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">userspace</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">mapping</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">MSIX</span><span class="w"> </span><span class="k">data</span>
<span class="w">    </span><span class="k">is</span><span class="w"> </span><span class="n">possible</span><span class="w"> </span><span class="n">now</span><span class="p">.</span><span class="w"> </span><span class="n">This</span><span class="w"> </span><span class="n">makes</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">QEMU</span><span class="w"> </span><span class="n">tries</span><span class="w"> </span><span class="n">mapping</span>
<span class="w">    </span><span class="n">the</span><span class="w"> </span><span class="n">entire</span><span class="w"> </span><span class="n">BAR</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">whole</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">emulate</span><span class="w"> </span><span class="n">MSIX</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="k">top</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">that</span><span class="p">.</span>

<span class="w">    </span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="nl">https</span><span class="p">:</span><span class="o">//</span><span class="n">git</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">org</span><span class="o">/</span><span class="n">pub</span><span class="o">/</span><span class="n">scm</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">kernel</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">torvalds</span><span class="o">/</span><span class="n">linux</span><span class="p">.</span><span class="n">git</span><span class="o">/</span><span class="k">commit</span><span class="o">/</span><span class="vm">?</span><span class="n">id</span><span class="o">=</span><span class="n">a32295c612c57990d17fb0f41e7134394b2f35f6</span>

<span class="w">    </span><span class="n">Signed</span><span class="o">-</span><span class="k">off</span><span class="o">-</span><span class="k">by</span><span class="err">:</span><span class="w"> </span><span class="n">Alexey</span><span class="w"> </span><span class="n">Kardashevskiy</span><span class="w"> </span><span class="o">&lt;</span><span class="n">aik</span><span class="nv">@ozlabs</span><span class="p">.</span><span class="n">ru</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">Reviewed</span><span class="o">-</span><span class="k">by</span><span class="err">:</span><span class="w"> </span><span class="n">David</span><span class="w"> </span><span class="n">Gibson</span><span class="w"> </span><span class="o">&lt;</span><span class="n">david</span><span class="nv">@gibson</span><span class="p">.</span><span class="n">dropbear</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">au</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">Signed</span><span class="o">-</span><span class="k">off</span><span class="o">-</span><span class="k">by</span><span class="err">:</span><span class="w"> </span><span class="n">Alex</span><span class="w"> </span><span class="n">Williamson</span><span class="w"> </span><span class="o">&lt;</span><span class="n">alex</span><span class="p">.</span><span class="n">williamson</span><span class="nv">@redhat</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span>
</code></pre></div>

<h3>3. VFIO中是如何建立DMA Remapping映射关系？</h3>
<p>前面的文章中我们反复提到VT-d DMA Remapping的原理和意义，那么在vfio中这又是如何实现的呢？</p>
<p>实现的原理其实不难，我们知道QEMU会维护虚拟机的物理地址空间映射关系，
而VT-d DMA Remapping需要建立GPA-&gt;HVA地址空间的映射关系，
那么当虚拟机的地址空间布局发生变化时我们都会尝试更新对应的DMA Remapping关系，
这是通过vfio_memory_listener来实现的。</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">MemoryListener</span><span class="w"> </span><span class="n">vfio_memory_listener</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">region_add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_listener_region_add</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">region_del</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_listener_region_del</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>

<p>vfio_connect_container函数中会将vfio_memory_listener注册给QEMU的物理地址空间address_space_memory，
这样vfio_memory_listener会监听虚拟机的物理地址空间变化，
调用对应的回调函数更新DMA Remapping关系。</p>
<div class="highlight"><pre><span></span><code><span class="n">memory_listener_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">container</span><span class="o">-&gt;</span><span class="n">listener</span><span class="p">,</span><span class="w"> </span><span class="n">container</span><span class="o">-&gt;</span><span class="n">space</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">);</span>
</code></pre></div>

<p>那么说了很久的IOMMU页表是如何创建和更新的呢？
看下vfio_listener_region_add/vfio_listener_region_del函数的实现就知道。
在该函数中先check对应的section是否是RAM（只对RAM类型的区域进行DMA Remapping），
再进行一些Sanity Check后调用vfio_dma_map将映射关系建立起来，
所以重点还是在于vfio_dma_map的函数实现。</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">vfio_listener_region_add</span><span class="p">(</span><span class="n">MemoryListener</span><span class="w"> </span><span class="o">*</span><span class="n">listener</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">MemoryRegionSection</span><span class="w"> </span><span class="o">*</span><span class="n">section</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">VFIOContainer</span><span class="w"> </span><span class="o">*</span><span class="n">container</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span><span class="w"> </span><span class="n">VFIOContainer</span><span class="p">,</span><span class="w"> </span><span class="n">listener</span><span class="p">);</span>
<span class="w">    </span><span class="n">hwaddr</span><span class="w"> </span><span class="n">iova</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">;</span>
<span class="w">    </span><span class="n">Int128</span><span class="w"> </span><span class="n">llend</span><span class="p">,</span><span class="w"> </span><span class="n">llsize</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">    </span><span class="n">VFIOHostDMAWindow</span><span class="w"> </span><span class="o">*</span><span class="n">hostwin</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">hostwin_found</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vfio_listener_skipped_section</span><span class="p">(</span><span class="n">section</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">// do dma_map only if MRS is RAM type</span>
<span class="w">        </span><span class="n">trace_vfio_listener_region_add_skip</span><span class="p">(</span>
<span class="w">                </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_address_space</span><span class="p">,</span>
<span class="w">                </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_address_space</span><span class="w"> </span><span class="o">+</span>
<span class="w">                </span><span class="n">int128_get64</span><span class="p">(</span><span class="n">int128_sub</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">int128_one</span><span class="p">())));</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">TARGET_PAGE_MASK</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span>
<span class="w">                 </span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_region</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">TARGET_PAGE_MASK</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">error_report</span><span class="p">(</span><span class="s">&quot;%s received unaligned region&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">iova</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TARGET_PAGE_ALIGN</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_address_space</span><span class="p">);</span>
<span class="w">    </span><span class="n">llend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int128_make64</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_address_space</span><span class="p">);</span>
<span class="w">    </span><span class="n">llend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int128_add</span><span class="p">(</span><span class="n">llend</span><span class="p">,</span><span class="w"> </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="n">llend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int128_and</span><span class="p">(</span><span class="n">llend</span><span class="p">,</span><span class="w"> </span><span class="n">int128_exts64</span><span class="p">(</span><span class="n">TARGET_PAGE_MASK</span><span class="p">));</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">int128_ge</span><span class="p">(</span><span class="n">int128_make64</span><span class="p">(</span><span class="n">iova</span><span class="p">),</span><span class="w"> </span><span class="n">llend</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int128_get64</span><span class="p">(</span><span class="n">int128_sub</span><span class="p">(</span><span class="n">llend</span><span class="p">,</span><span class="w"> </span><span class="n">int128_one</span><span class="p">()));</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">container</span><span class="o">-&gt;</span><span class="n">iommu_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VFIO_SPAPR_TCE_v2_IOMMU</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">hwaddr</span><span class="w"> </span><span class="n">pgsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* For now intersections are not allowed, we may relax this later */</span>
<span class="w">        </span><span class="n">QLIST_FOREACH</span><span class="p">(</span><span class="n">hostwin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">container</span><span class="o">-&gt;</span><span class="n">hostwin_list</span><span class="p">,</span><span class="w"> </span><span class="n">hostwin_next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ranges_overlap</span><span class="p">(</span><span class="n">hostwin</span><span class="o">-&gt;</span><span class="n">min_iova</span><span class="p">,</span>
<span class="w">                               </span><span class="n">hostwin</span><span class="o">-&gt;</span><span class="n">max_iova</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">hostwin</span><span class="o">-&gt;</span><span class="n">min_iova</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                               </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_address_space</span><span class="p">,</span>
<span class="w">                               </span><span class="n">int128_get64</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">                </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_spapr_create_window</span><span class="p">(</span><span class="n">container</span><span class="p">,</span><span class="w"> </span><span class="n">section</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pgsize</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">vfio_host_win_add</span><span class="p">(</span><span class="n">container</span><span class="p">,</span><span class="w"> </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_address_space</span><span class="p">,</span>
<span class="w">                          </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_address_space</span><span class="w"> </span><span class="o">+</span>
<span class="w">                          </span><span class="n">int128_get64</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">pgsize</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_KVM</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">kvm_enabled</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">VFIOGroup</span><span class="w"> </span><span class="o">*</span><span class="n">group</span><span class="p">;</span>
<span class="w">            </span><span class="n">IOMMUMemoryRegion</span><span class="w"> </span><span class="o">*</span><span class="n">iommu_mr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IOMMU_MEMORY_REGION</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">);</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">kvm_vfio_spapr_tce</span><span class="w"> </span><span class="n">param</span><span class="p">;</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">kvm_device_attr</span><span class="w"> </span><span class="n">attr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KVM_DEV_VFIO_GROUP</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">attr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KVM_DEV_VFIO_GROUP_SET_SPAPR_TCE</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span>
<span class="w">            </span><span class="p">};</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">memory_region_iommu_get_attr</span><span class="p">(</span><span class="n">iommu_mr</span><span class="p">,</span><span class="w"> </span><span class="n">IOMMU_ATTR_SPAPR_TCE_FD</span><span class="p">,</span>
<span class="w">                                              </span><span class="o">&amp;</span><span class="n">param</span><span class="p">.</span><span class="n">tablefd</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">QLIST_FOREACH</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">container</span><span class="o">-&gt;</span><span class="n">group_list</span><span class="p">,</span><span class="w"> </span><span class="n">container_next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">param</span><span class="p">.</span><span class="n">groupfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">vfio_kvm_device_fd</span><span class="p">,</span><span class="w"> </span><span class="n">KVM_SET_DEVICE_ATTR</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">attr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">error_report</span><span class="p">(</span><span class="s">&quot;vfio: failed to setup fd %d &quot;</span>
<span class="w">                                     </span><span class="s">&quot;for a group with fd %d: %s&quot;</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">param</span><span class="p">.</span><span class="n">tablefd</span><span class="p">,</span><span class="w"> </span><span class="n">param</span><span class="p">.</span><span class="n">groupfd</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
<span class="w">                        </span><span class="k">return</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="n">trace_vfio_spapr_group_attach</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">groupfd</span><span class="p">,</span><span class="w"> </span><span class="n">param</span><span class="p">.</span><span class="n">tablefd</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">hostwin_found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="n">QLIST_FOREACH</span><span class="p">(</span><span class="n">hostwin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">container</span><span class="o">-&gt;</span><span class="n">hostwin_list</span><span class="p">,</span><span class="w"> </span><span class="n">hostwin_next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hostwin</span><span class="o">-&gt;</span><span class="n">min_iova</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">iova</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">hostwin</span><span class="o">-&gt;</span><span class="n">max_iova</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">hostwin_found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">hostwin_found</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">error_report</span><span class="p">(</span><span class="s">&quot;vfio: IOMMU container %p can&#39;t map guest IOVA region&quot;</span>
<span class="w">                     </span><span class="s">&quot; 0x%&quot;</span><span class="n">HWADDR_PRIx</span><span class="s">&quot;..0x%&quot;</span><span class="n">HWADDR_PRIx</span><span class="p">,</span>
<span class="w">                     </span><span class="n">container</span><span class="p">,</span><span class="w"> </span><span class="n">iova</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">memory_region_ref</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">);</span><span class="w">     </span><span class="c1">// increase ref of MR by one</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memory_region_is_iommu</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">      </span><span class="c1">// guest IOMMU emulation</span>
<span class="w">        </span><span class="n">VFIOGuestIOMMU</span><span class="w"> </span><span class="o">*</span><span class="n">giommu</span><span class="p">;</span>
<span class="w">        </span><span class="n">IOMMUMemoryRegion</span><span class="w"> </span><span class="o">*</span><span class="n">iommu_mr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IOMMU_MEMORY_REGION</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">);</span>

<span class="w">        </span><span class="n">trace_vfio_listener_region_add_iommu</span><span class="p">(</span><span class="n">iova</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * FIXME: For VFIO iommu types which have KVM acceleration to</span>
<span class="cm">         * avoid bouncing all map/unmaps through qemu this way, this</span>
<span class="cm">         * would be the right place to wire that up (tell the KVM</span>
<span class="cm">         * device emulation the VFIO iommu handles to use).</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">giommu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_malloc0</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">giommu</span><span class="p">));</span>
<span class="w">        </span><span class="n">giommu</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iommu_mr</span><span class="p">;</span>
<span class="w">        </span><span class="n">giommu</span><span class="o">-&gt;</span><span class="n">iommu_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_address_space</span><span class="w"> </span><span class="o">-</span>
<span class="w">                               </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_region</span><span class="p">;</span>
<span class="w">        </span><span class="n">giommu</span><span class="o">-&gt;</span><span class="n">container</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container</span><span class="p">;</span>
<span class="w">        </span><span class="n">llend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int128_add</span><span class="p">(</span><span class="n">int128_make64</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_region</span><span class="p">),</span>
<span class="w">                           </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="w">        </span><span class="n">llend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int128_sub</span><span class="p">(</span><span class="n">llend</span><span class="p">,</span><span class="w"> </span><span class="n">int128_one</span><span class="p">());</span>
<span class="w">        </span><span class="n">iommu_notifier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">giommu</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">vfio_iommu_map_notify</span><span class="p">,</span>
<span class="w">                            </span><span class="n">IOMMU_NOTIFIER_ALL</span><span class="p">,</span>
<span class="w">                            </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_region</span><span class="p">,</span>
<span class="w">                            </span><span class="n">int128_get64</span><span class="p">(</span><span class="n">llend</span><span class="p">));</span>
<span class="w">        </span><span class="n">QLIST_INSERT_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">container</span><span class="o">-&gt;</span><span class="n">giommu_list</span><span class="p">,</span><span class="w"> </span><span class="n">giommu</span><span class="p">,</span><span class="w"> </span><span class="n">giommu_next</span><span class="p">);</span>

<span class="w">        </span><span class="n">memory_region_register_iommu_notifier</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">giommu</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">);</span>
<span class="w">        </span><span class="n">memory_region_iommu_replay</span><span class="p">(</span><span class="n">giommu</span><span class="o">-&gt;</span><span class="n">iommu</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">giommu</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Here we assume that memory_region_is_ram(section-&gt;mr)==true */</span>

<span class="w">    </span><span class="n">vaddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_region_get_ram_ptr</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">        </span><span class="c1">// get hva</span>
<span class="w">            </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_region</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="p">(</span><span class="n">iova</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_address_space</span><span class="p">);</span>

<span class="w">    </span><span class="n">trace_vfio_listener_region_add_ram</span><span class="p">(</span><span class="n">iova</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">vaddr</span><span class="p">);</span>

<span class="w">    </span><span class="n">llsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int128_sub</span><span class="p">(</span><span class="n">llend</span><span class="p">,</span><span class="w"> </span><span class="n">int128_make64</span><span class="p">(</span><span class="n">iova</span><span class="p">));</span><span class="w">        </span><span class="c1">// calc map size</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memory_region_is_ram_device</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">hwaddr</span><span class="w"> </span><span class="n">pgmask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1ULL</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ctz64</span><span class="p">(</span><span class="n">hostwin</span><span class="o">-&gt;</span><span class="n">iova_pgsizes</span><span class="p">))</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">iova</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">pgmask</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">int128_get64</span><span class="p">(</span><span class="n">llsize</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">pgmask</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">trace_vfio_listener_region_add_no_dma_map</span><span class="p">(</span>
<span class="w">                </span><span class="n">memory_region_name</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">),</span>
<span class="w">                </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">offset_within_address_space</span><span class="p">,</span>
<span class="w">                </span><span class="n">int128_getlo</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">),</span>
<span class="w">                </span><span class="n">pgmask</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vfio_dma_map</span><span class="p">(</span><span class="n">container</span><span class="p">,</span><span class="w"> </span><span class="n">iova</span><span class="p">,</span><span class="w"> </span><span class="n">int128_get64</span><span class="p">(</span><span class="n">llsize</span><span class="p">),</span><span class="w">   </span><span class="c1">// do VFIO_IOMMU_MAP_DMA</span>
<span class="w">                       </span><span class="n">vaddr</span><span class="p">,</span><span class="w"> </span><span class="n">section</span><span class="o">-&gt;</span><span class="n">readonly</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">error_report</span><span class="p">(</span><span class="s">&quot;vfio_dma_map(%p, 0x%&quot;</span><span class="n">HWADDR_PRIx</span><span class="s">&quot;, &quot;</span>
<span class="w">                     </span><span class="s">&quot;0x%&quot;</span><span class="n">HWADDR_PRIx</span><span class="s">&quot;, %p) = %d (%m)&quot;</span><span class="p">,</span>
<span class="w">                     </span><span class="n">container</span><span class="p">,</span><span class="w"> </span><span class="n">iova</span><span class="p">,</span><span class="w"> </span><span class="n">int128_get64</span><span class="p">(</span><span class="n">llsize</span><span class="p">),</span><span class="w"> </span><span class="n">vaddr</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memory_region_is_ram_device</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Allow unexpected mappings not to be fatal for RAM devices */</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="p">;</span>

<span class="nl">fail</span><span class="p">:</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memory_region_is_ram_device</span><span class="p">(</span><span class="n">section</span><span class="o">-&gt;</span><span class="n">mr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">error_report</span><span class="p">(</span><span class="s">&quot;failed to vfio_dma_map. pci p2p may not work&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * On the initfn path, store the first error in the container so we</span>
<span class="cm">     * can gracefully fail.  Runtime, there&#39;s not much we can do other</span>
<span class="cm">     * than throw a hardware error.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">container</span><span class="o">-&gt;</span><span class="n">initialized</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">container</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">container</span><span class="o">-&gt;</span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">hw_error</span><span class="p">(</span><span class="s">&quot;vfio: DMA mapping failed, unable to continue&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>vfio_dma_map函数中会传入建立DMA Remapping的基本信息，
这里是用数据结构vfio_iommu_type1_dma_map来描述，
然后交给内核去做DMA Remapping。</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">vfio_iommu_type1_dma_map</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">argsz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">map</span><span class="p">),</span>
<span class="w">        </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VFIO_DMA_MAP_FLAG_READ</span><span class="p">,</span><span class="w">    </span><span class="c1">// flags</span>
<span class="w">        </span><span class="p">.</span><span class="n">vaddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">__u64</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">vaddr</span><span class="p">,</span><span class="w">   </span><span class="c1">// HVA</span>
<span class="w">        </span><span class="p">.</span><span class="n">iova</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iova</span><span class="p">,</span><span class="w">                       </span><span class="c1">// iova -&gt; gpa</span>
<span class="w">        </span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w">                       </span><span class="c1">// map size</span>
<span class="w">    </span><span class="p">};</span>
</code></pre></div>

<p>该函数对应的内核调用栈见下面的图，其主要流程包含2个步骤，简称pin和map：</p>
<ul>
<li>vfio_pin_pages_remote 把虚拟机的物理内存都pin住，物理内存不能交换</li>
<li>vfio_iommu_map 创建虚拟机domain的IOMMU页表，DMA Remapping地址翻译时候使用</li>
</ul>
<p>值得注意的是在pin步骤中，
pin虚拟机物理内存是调用get_user_pages_fast来实现的，
如果虚拟机的内存未申请那么会先将内存申请出来，
这个过程可能会非常耗时并且会持有进程的mmap_sem大锁。</p>
<div class="highlight"><pre><span></span><code><span class="n">vfio_dma_do_map</span>
<span class="o">--------------------------------------------------------------</span>
<span class="n">vfio_pin_map_dma</span>
<span class="w">    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_pin_pages_remote</span><span class="w">   </span><span class="c1">// pin pages in memory</span>
<span class="w">        </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vaddr_get_pfn</span>
<span class="w">            </span><span class="o">|</span><span class="n">get_user_pages_fast</span>
<span class="w">                </span><span class="o">|</span><span class="n">gup_pud_range</span>
<span class="w">                    </span><span class="n">gup_pud_range</span>
<span class="w">                        </span><span class="n">gup_pte_range</span>
<span class="w">                            </span><span class="n">get_page</span><span class="w">   </span><span class="c1">// pin page, without mm-&gt;mmap_sem held</span>
<span class="w">                </span><span class="o">|</span><span class="n">get_user_pages_unlocked</span>
<span class="w">                    </span><span class="n">__get_user_pages_locked</span>
<span class="w">                        </span><span class="n">__get_user_pages</span>
<span class="w">                            </span><span class="o">|</span><span class="n">handle_mm_fault</span>
<span class="w">                                </span><span class="n">__handle_mm_fault</span><span class="w"> </span><span class="c1">// do_page_fault process</span>
<span class="w">                                    </span><span class="n">alloc</span><span class="w"> </span><span class="n">pud</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="o">-&gt;</span><span class="n">pte</span>
<span class="w">                                    </span><span class="n">handle_pte_fault</span>
<span class="w">                                        </span><span class="n">do_anonymous_page</span>
<span class="w">                                            </span><span class="n">alloc_zeroed_user_highpage_movable</span>
<span class="w">                                            </span><span class="p">...</span><span class="w"> </span><span class="n">alloc</span><span class="w"> </span><span class="n">page</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">__GFP_ZERO</span>
<span class="w">                            </span><span class="o">|</span><span class="n">_get_page</span>
<span class="w">                                </span><span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page_count</span><span class="p">)</span><span class="w"> </span><span class="c1">// pin page</span>
<span class="w">            </span><span class="o">|</span><span class="n">get_user_pages_remote</span>
<span class="w">                </span><span class="n">__get_user_pages_locked</span>

<span class="w">    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_iommu_map</span><span class="w">  </span><span class="c1">// create IOMMU domain page table</span>
<span class="w">        </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">iommu_map</span>
<span class="w">            </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">intel_iommu_map</span><span class="w">     </span><span class="c1">// intel-iommu.c</span>
<span class="w">                </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">domain_pfn_mapping</span>
<span class="w">                    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">pfn_to_dma_pte</span>
</code></pre></div>

<p>同理，vfio_listener_region_add回调函数实现了DMA Remapping关系的反注册。</p>
<h3>4. VFIO中又是如何支持设备热插拔的？</h3>
<p>vfio热插拔仍然是走的QEMU设备热插拔流程，大致流程如下：</p>
<div class="highlight"><pre><span></span><code><span class="n">qdev_device_add</span>
<span class="w">    </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">device_set_realized</span>
<span class="w">        </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">hotplug_handler_plug</span>
<span class="w">            </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">piix4_device_plug_cb</span>
<span class="w">                </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">piix4_send_gpe</span><span class="w"> </span><span class="c1">// inject ACPI GPE to guest OS</span>
<span class="w">        </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">pci_qdev_realize</span>
<span class="w">                </span><span class="o">|-&gt;</span><span class="w"> </span><span class="n">vfio_realize</span>
</code></pre></div>

<p>device_set_realized函数负责将设备上线，
piix4_send_gpe函数中会注入一个ACPI GPE事件通知GuestOS，
vfio_realize函数负责整个vfio的设备初始化流程。
那么vfio_realize中主要做了哪些事情呢？
可以用下面这一张图概括~<a href="https://kernelgo.org/images/qemu-vfio.svg">点击链接查看原图</a></p>
<p>vfio_realize的具体流程这里就不再展开免得啰嗦！
感兴趣的请自己分析代码去，所有的vfio实现细节都在这里面。</p>
<p><img alt="vfio-pci-bar" src="../images/qemu-vfio.svg"></p>


             
 
                <p id="post-share-links">
    Share on:
      <a href="https://twitter.com/intent/tweet?text=VFIO%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%82%B9%E5%88%86%E6%9E%90&url=https%3A//blog.kernel.love/vfio-insight.html&hashtags=virtualization" target="_blank" rel="nofollow noopener noreferrer" title="Share on Twitter">Twitter</a>
 ❄       <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A//blog.kernel.love/vfio-insight.html" target="_blank" rel="nofollow noopener noreferrer" title="Share on Facebook">Facebook</a>
 ❄       <a href="mailto:?subject=VFIO%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%82%B9%E5%88%86%E6%9E%90&amp;body=https%3A//blog.kernel.love/vfio-insight.html" target="_blank" rel="nofollow noopener noreferrer" title="Share via Email">Email</a>

            
            







            <hr/>
<section>
    <h2>Related Posts</h2>
<ul class="related-posts-list">
<li><a href="https://blog.kernel.love/vtd-posted-interrupt-code-analysis.html" title="VT-d Interrupt Posting代码分析">VT-d Interrupt Posting代码分析</a></li>
<li><a href="https://blog.kernel.love/x86-nmi.html" title="Virt NMI Emulation">Virt NMI Emulation</a></li>
<li><a href="https://blog.kernel.love/microVM.html" title="轻量级虚拟化技术">轻量级虚拟化技术</a></li>
<li><a href="https://blog.kernel.love/virtio-overview.html" title="Virtio Spec Overview">Virtio Spec Overview</a></li>
<li><a href="https://blog.kernel.love/amd-x2avic.html" title="AMD X2AVIC 理解">AMD X2AVIC 理解</a></li>
</ul>
<hr />
</section>
            <aside>
            <nav>
            <ul class="articles-timeline">
                <li class="previous-article">« <a href="https://blog.kernel.love/intel_iommu.html" title="Previous: Intel IOMMU功能介绍">Intel IOMMU功能介绍</a></li>
                <li class="next-article"><a href="https://blog.kernel.love/kernel-debug-using-qemu.html" title="Next: 使用gdb和qemu来调试linux内核">使用gdb和qemu来调试linux内核</a> »</li>
            </ul>
            </nav>
            </aside>
        </div>
        <section id="article-sidebar" class="span2">
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2018-05-28T23:00:00+08:00">Mon 28 May 2018</time>

            <h4>Category</h4>
            <a class="category-link" href="https://blog.kernel.love/categories.html#virt-ref">virt</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://blog.kernel.love/tags.html#virtualization-ref">virtualization
                    <span class="superscript">13</span>
</a></li>
            </ul>
<h4>Contact</h4>
<div id="sidebar-social-link">
    <a href="https://github.com/fangying" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="GitHub" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1B1817"/><path fill="#fff" d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
    </a>
</div>
            





            





        </section>
</div>
</article>
<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides.
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>                    </div>
                    <div class="span1"></div>
                </div>
            </div>
        </div>
<footer>
    <div>
        <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title"> blog.kernel.love"</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://blog.kernel.love" property="cc:attributionName" rel="cc:attributionURL">Yori Fang</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </div>




    <div id="fpowered">
        Powered by: <a href="http://getpelican.com/" title="Pelican Home Page" target="_blank" rel="nofollow noopener noreferrer">Pelican</a>
        Theme: <a href="https://elegant.oncrashreboot.com/" title="Theme Elegant Home Page" target="_blank" rel="nofollow noopener noreferrer">Elegant</a>
    </div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script src="https://blog.kernel.love/theme/js/elegant.prod.9e9d5ce754.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    <script>
    (function () {
        if (window.location.hash.match(/^#comment-\d+$/)) {
            $('#comment_thread').collapse('show');
        }
    })();
    window.onhashchange=function(){
        if (window.location.hash.match(/^#comment-\d+$/))
            window.location.reload(true);
    }
    $('#comment_thread').on('shown', function () {
        var link = document.getElementById('comment-accordion-toggle');
        var old_innerHTML = link.innerHTML;
        $(link).fadeOut(200, function() {
            $(this).text('Click here to hide comments').fadeIn(200);
        });
        $('#comment_thread').on('hidden', function () {
            $(link).fadeOut(200, function() {
                $(this).text(old_innerHTML).fadeIn(200);
            });
        })
    })
</script>

    </body>
    <!-- Theme: Elegant built for Pelican
        License : MIT -->
</html>